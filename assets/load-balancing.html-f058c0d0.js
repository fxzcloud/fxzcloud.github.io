import{_ as i,V as a,W as l,$ as e}from"./framework-159025ca.js";const r={},n=e('<h1 id="常见的负载均衡算法" tabindex="-1"><a class="header-anchor" href="#常见的负载均衡算法" aria-hidden="true">#</a> 常见的负载均衡算法</h1><p>负载均衡是一种用于分发网络或应用服务请求的技术，以确保服务器资源得到有效利用、降低延迟，并提高系统的稳定性和可靠性。</p><p><strong>常见的负载均衡方案</strong></p><ol><li><strong>基于DNS的负载均衡</strong>： <ul><li>DNS服务器返回多个IP地址，客户端根据返回的地址选择其中一个进行连接。</li><li>优点：简单易行，无需额外设备。</li><li>缺点：无法动态调整负载，缺乏灵活性。</li></ul></li><li><strong>四层负载均衡</strong>： <ul><li>在传输层（第四层）进行负载均衡，主要考虑IP地址和端口号等信息。</li><li>常见设备：F5 BIG-IP、Citrix ADC等。</li><li>优点：可以实现TCP和UDP层面的负载均衡。</li><li>缺点：无法针对具体应用进行更精细的调控。</li></ul></li><li><strong>七层负载均衡</strong>： <ul><li>在应用层（第七层）进行负载均衡，考虑HTTP头、URL等应用层信息。</li><li>常见设备：Nginx、HAProxy等。</li><li>优点：可以基于具体应用协议进行负载均衡，实现更精细的控制。</li><li>缺点：对系统性能有一定要求。</li></ul></li><li><strong>内容感知型负载均衡</strong>： <ul><li>结合七层负载均衡，可以根据请求内容进行智能分发，以提高性能和用户体验。</li></ul></li><li><strong>全局负载均衡（GSLB）</strong>： <ul><li>用于跨多个数据中心或地理位置，根据用户位置、网络条件等因素进行负载均衡，以降低延迟并提高服务可用性。</li></ul></li></ol><p>本文仅讲述常见的负载均衡算法。</p><h2 id="一、随机" tabindex="-1"><a class="header-anchor" href="#一、随机" aria-hidden="true">#</a> 一、随机</h2><h3 id="_1-完全随机" tabindex="-1"><a class="header-anchor" href="#_1-完全随机" aria-hidden="true">#</a> 1. 完全随机</h3><p>该算法简单地从服务器列表中随机选择一个来处理请求。这种方法的优点是实现简单，但缺点在于无法保证负载的均衡性，某些服务器可能会因此承受更大的负载，同时也无法根据服务器的配置分发请求。</p><h3 id="_2-加权随机" tabindex="-1"><a class="header-anchor" href="#_2-加权随机" aria-hidden="true">#</a> 2. 加权随机</h3><p>假设我们现在有3台服务器，A服务器的权重为3，B服务器的权重为5，C服务器的权重为1。然后我们随机生成一个数：</p><ul><li>如果生成的随机数为1，1 ≤ 3，那么此时请求在落在A的区间段，请求应该交由A来处理；</li><li>如果生成的随机数为5，那么此时 3 ＜ 5，所以不在A区间，而 5 - 3 = 2 &lt; 5，那么此时应该落在B区间；</li><li>如果生成的随机数为9，那么 9 &gt; 3 + 5，所以不可能落在A区间或者B区间，而刚好后面C的权重为，落在C区间。</li></ul><p>用图展示会更直观些，假设下面数组下标从1开始：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/202403131339404.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>当然我们不可能真的像图中那样再去维护一个数组了，这样不也和刚刚那样白占内存么。所以每次但一个随机数过来时，我们会先去判断它是否小于A的权重，如果小于，那么就是请求发到A，如果不小于，<strong>注意</strong>，这里就得将随机数减去A的权重，然后下一次循环再和B的权重比，如果小于B的权重，那么就是请求到B。</p><h2 id="二、轮询" tabindex="-1"><a class="header-anchor" href="#二、轮询" aria-hidden="true">#</a> 二、轮询</h2><h3 id="_1-完全轮询" tabindex="-1"><a class="header-anchor" href="#_1-完全轮询" aria-hidden="true">#</a> 1. 完全轮询</h3><p>按照顺序将请求依次分发给后端服务器，在每一轮请求中，请求会依次分配给不同的服务器。这是一种简单公平的负载均衡算法。但是，它也无法考虑服务器的实际负载情况。</p><h3 id="_2-加权轮询" tabindex="-1"><a class="header-anchor" href="#_2-加权轮询" aria-hidden="true">#</a> 2. 加权轮询</h3><p>在轮询的基础上引入了权重概念，不同服务器可以设置不同的权重值，从而实现按比例分配负载的效果。</p><h2 id="三、一致性hash" tabindex="-1"><a class="header-anchor" href="#三、一致性hash" aria-hidden="true">#</a> 三、一致性Hash</h2><p>其实我们可以发现，随机和轮询的思想其实差不多，都是尽可能将请求均衡地派发到服务器中，最多加权实现。如果我们现在想要让某个用于发过来的请求一直打到相同的服务器上去处理，那该怎么办呢？</p><p>常见的实现就是一致性Hash算法了，这一算法在Nginx中配置负载均衡时也有体现：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/202403131343576.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如上图，当有相同用户的连接过来的时候，可以通过Hash映射的方式打到同一台服务器上，这也是解决分布式Session的一种思路。</p><blockquote><p>首先用户的请求过来，根据Hash算法计算出对应的值后，如何找到对应的服务器IP呢？</p></blockquote><p>这很简单，将所有可能的HashCode值列出来，造一个Map，将HashCode与IP一一对应，大概多个HashCode会对应到同一台机器。</p><blockquote><p>那如果HashCode的可能值有很多个呢？那岂不是需要去造一个占用内存很大的Map？</p></blockquote><p>客户端发起的请求情况是无穷无尽的（客户端地址不同，请求参数不同等等），所以对于哈希值也是无穷大的，所以我们不可能把所有的哈希值都进行映射到服务端IP上，这里就需要用到哈希环了，如下图(其实是映射到哈希槽里，通过哈希槽可以解决增删服务器造成的映射问题)：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/202403131343379.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><p>哈希值如果在ip1和ip2之间，则应该选择ip2作为响应服务器；</p></li><li><p>哈希值如果在ip2和ip3之间，则应该选择ip3作为响应服务器；</p></li><li><p>哈希值如果在ip3和ip4之间，则应该选择ip4作为响应服务器；</p></li><li><p>哈希值如果在ip4和ip1之间，则应该选择ip1作为响应服务器；</p></li></ul><blockquote><p>如果多台服务器所“控制”的区域很小，或者有时候其中一台服务器宕机了，像下面这种出现哈希倾斜的情况，怎么办？</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/202403131343836.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>像这种情况可以加入虚拟节点，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/202403131343557.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>其中ip1-2、ip2-1等节点其实是虚拟的，等同于ip1和ip2服务器本身。实际上，这只是处理这种不平衡性的一种思路，实际上就算哈希环本身是平衡的，你也可以加入如更多的虚拟节点来使这个环更加平滑。</p><h2 id="四、最小连接数法" tabindex="-1"><a class="header-anchor" href="#四、最小连接数法" aria-hidden="true">#</a> 四、最小连接数法</h2><p>将请求分发给当前连接数最少的服务器。通过动态监测服务器连接数来进行负载均衡，以确保负载更均衡。</p><p>但这有个问题，如果出现网络延迟，所有的请求会都会打到一台机器上。。。</p>',38),t=[n];function p(h,d){return a(),l("div",null,t)}const g=i(r,[["render",p],["__file","load-balancing.html.vue"]]);export{g as default};
