import{_ as i,V as t,W as n,$ as p}from"./framework-159025ca.js";const o={},e=p('<h1 id="sentinel" tabindex="-1"><a class="header-anchor" href="#sentinel" aria-hidden="true">#</a> sentinel</h1><h3 id="_1-什么是sentinel" tabindex="-1"><a class="header-anchor" href="#_1-什么是sentinel" aria-hidden="true">#</a> 1.什么是sentinel？</h3><p>sentinel顾名思义：卫兵；在Redis中叫做哨兵，用于监控主从切换，但是在微服务中叫做流量防卫兵。</p><p>Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><p>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。</p><p>完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><p>Sentinel 的主要特性如下图： <img src="https://minio.pigx.top/oss/2022/08/QrBsmb.png" alt="" loading="lazy"></p><p>Sentinel 分为两个部分:</p><p>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</p><p>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p><h3 id="_2-sentinel和hystrix有何区别" tabindex="-1"><a class="header-anchor" href="#_2-sentinel和hystrix有何区别" aria-hidden="true">#</a> 2.sentinel和Hystrix有何区别？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/417wi8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-流量控制如何配置" tabindex="-1"><a class="header-anchor" href="#_3-流量控制如何配置" aria-hidden="true">#</a> 3.流量控制如何配置？</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p><strong>QPS</strong>：每秒请求数，即在不断向服务器发送请求的情况下，服务器每秒能够处理的请求数量。</p><p><strong>并发线程数</strong>：指的是施压机施加的同时请求的线程数量。</p><p>同一个资源可以创建多条限流规则，一条限流规则由以下元素组成：</p><p><strong>resource</strong>：资源名，即限流规则的作用对象。</p><p><strong>count</strong>： 限流阈值</p><p><strong>grade</strong>：限流阈值类型（1：QPS 0：并发线程数），默认值QPS</p><p><strong>limitApp</strong>：流控针对的调用来源，若为 default 则不区分调用来源，默认值default</p><p><strong>strategy</strong>：判断的根据是资源自身**(0)，还是根据其它关联资源 (1)，还是根据链路入口(2)**，默认值根据资源本身。</p><p><strong>controlBehavior</strong>： 流控效果（直接拒绝(0) / 排队等待(2) / 预热冷启动(1))，默认值直接拒绝。 以上元素限流元素对应的类是<code>com.alibaba.csp.sentinel.slots.block.flow.FlowRule</code>，各元素如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/MoBikl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/MJsrak.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-三种流控效果" tabindex="-1"><a class="header-anchor" href="#_4-三种流控效果" aria-hidden="true">#</a> 4.三种流控效果</h3><p>流控效果总共分为三种，对应元素controlBehavior，分别如下：</p><ol><li><strong>快速失败</strong></li></ol><p>默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。</p><ol start="2"><li><strong>warm up</strong></li></ol><p>即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><p>注意：这一效果只针对QPS流控，并发线程数流控不支持。 预热底层是根据令牌桶算法实现的，源码对应得类在com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController。</p><p><strong>算法中有一个冷却因子coldFactor，默认值是3，即请求 QPS 从 threshold(阈值) / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。</strong></p><p>比如设定QPS阈值为3，流控效果为warm up，预热时长为5秒，如下图： <img src="https://minio.pigx.top/oss/2022/08/3xhE93.png" alt="" loading="lazy"></p><ol start="3"><li><strong>排队等待</strong></li></ol><p>匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。源码对应得类：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p><p>注意：这一效果只针对QPS流控，并发线程数流控不支持。</p><p>简单举个栗子：你去大学食堂吃饭，只有一个阿姨在打饭，那么所有人都要排队打饭，每次只有一个人打到饭，其他人都在排队等待。</p><p>不同的是sentinel有个超时等待时间，一旦超过这个预定设置的时间将会被限流。 <img src="https://minio.pigx.top/oss/2022/08/DlqbSj.png" alt="" loading="lazy"></p><blockquote><p>这种方式适合用于请求以突刺状来到，这个时候我们不希望一下子把所有的请求都通过，这样可能会把系统压垮；同时我们也期待系统以稳定的速度，逐步处理这些请求，以起到“<strong>削峰填谷</strong>”的效果，而不是拒绝所有请求。</p></blockquote><p>比如设置QPS阈值为1，超时等待时间为10000毫秒，如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/JNrJWZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-三种流控模式" tabindex="-1"><a class="header-anchor" href="#_5-三种流控模式" aria-hidden="true">#</a> 5. 三种流控模式</h3><p>流控模式总共分为三种，对应元素strategy，分别如下：</p><ol><li><p>直接拒绝：接口达到限流条件时，直接限流</p></li><li><p>关联：当关联的资源达到阈值时，就限流自己</p></li><li><p>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）</p></li></ol><p>下面来详细介绍下以上三种流控模式。</p><p><strong>直接拒绝</strong></p><p>顾名思义：默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。上面的几个例子都是配置了直接拒绝这个模式，这里不再详细介绍。</p><p><strong>关联</strong></p><p>典型的使用场景：一个是支付接口，一个是下单接口，此时一旦支付接口达到了阈值，那么订单接口就应该被限流，不然这边还在下单，消费者等待或者直接被拒绝支付将会极大的影响用户体验。</p><p>简而言之：A关联B，一旦B达到阈值，则A被限流</p><h3 id="_6-两种统计类型" tabindex="-1"><a class="header-anchor" href="#_6-两种统计类型" aria-hidden="true">#</a> 6.两种统计类型</h3><p>流控分为两种统计类型，分别是<strong>QPS</strong>，<strong>并发线程数</strong></p><p><strong>举个栗子</strong>：陈某带了一个亿去银行存钱，但是银行大门保安要查健康码，每秒最多只能同时进入4个人，并且银行中只有两个工作人员工作，如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/hky6e9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>此时的QPS含义</strong>：从保安到银行这一段，即是保安放行进入银行的人数。</p><p><strong>此时并发线程数的含义</strong>：银行只有两个工作人员在工作，那么最多只能同时处理两个任务，这里并发线程数的阈值就是2。</p><h3 id="_7-降级规则如何配置" tabindex="-1"><a class="header-anchor" href="#_7-降级规则如何配置" aria-hidden="true">#</a> 7.降级规则如何配置？</h3><p>熔断降级在日常生活中也是比较常见的，场景如下：</p><ul><li>股票市场的熔断，当价格触发到了熔点之后，会暂停交易一段时间，或者交易可以继续进行，但是报价会限制在一定的范围。</li><li>电压过高导致保险丝触发熔断保护</li></ul><p>在大型的分布式系统中，一个请求的依赖如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/WkV9VB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果这个时候，某个服务出现一些异常，比如：</p><ol><li><p>服务提供者不可用(硬件故障、程序bug、网络故障、用户请求量较大)</p></li><li><p>重试导致的流量过大</p></li><li><p>服务调用者使用同步调用，产生大量的等待线程占用系统资源，一旦线程资源被耗尽，调用者提供的服务也会变成不可用状态</p></li></ol><p>那么将会导致整个服务不可用，用古话来讲就是：千里之堤毁于蚁穴。</p><p>所谓编程源于生活，架构师们根据生活的经验设计出了服务的熔断降级策略，很好的解决了这类问题。</p><p>熔断降级规则对应sentinel控制台的降级规则这一栏，如下图： <img src="https://minio.pigx.top/oss/2022/08/C2nqFn.png" alt="" loading="lazy"></p><p>熔断降级涉及到的几个属性如下表：</p><figure><img src="https://minio.pigx.top/oss/2022/08/4rRDtE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>源码中对应得类为：com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule。</p><h3 id="_8-三种熔断策略" tabindex="-1"><a class="header-anchor" href="#_8-三种熔断策略" aria-hidden="true">#</a> 8.三种熔断策略</h3><p>Sentinel 提供以下几种熔断策略：</p><ol><li><p>平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p></li><li><p>异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p></li><li><p>异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p></li></ol><h3 id="_9-热点参数如何限流" tabindex="-1"><a class="header-anchor" href="#_9-热点参数如何限流" aria-hidden="true">#</a> 9.热点参数如何限流？</h3><p>顾名思义：热点就是经常访问的数据，很多时候肯定是希望统计某个访问频次Top K数据并对其进行限流。</p><p>比如秒杀系统中的商品ID，对于热点商品那一瞬间的并发量是非常可怕的，因此必须要对其进行限流。</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p><p>注意：热点参数限流只针对QPS。 <img src="https://minio.pigx.top/oss/2022/08/zSTkks.png" alt="" loading="lazy"></p><p>规则对应得源码在<code>com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule</code>这个类中，各种属性含义如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/57vYA3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_10-系统自适应如何限流" tabindex="-1"><a class="header-anchor" href="#_10-系统自适应如何限流" aria-hidden="true">#</a> 10.系统自适应如何限流？</h3><p>前面热点参数、普通流量限流都是针对的某个接口，这里系统自适应限流针对是整个系统的入口流量，从单台机器的 <strong>load</strong>、<strong>CPU 使用率</strong>、<strong>平均 RT</strong>、<strong>入口 QPS</strong> 和<strong>并发线程数</strong>等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><figure><img src="https://minio.pigx.top/oss/2022/08/7wXzIl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>阈值类型有五种，分别如下：</p><p>Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</p><p>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</p><p>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p><p>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p><p>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p>',92),a=[e];function s(r,l){return t(),n("div",null,a)}const d=i(o,[["render",s],["__file","11-sentinel.html.vue"]]);export{d as default};
