import{_ as a,V as n,W as s,$ as e}from"./framework-159025ca.js";const t={},i=e(`<h1 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> Mybatis</h1><h3 id="_1-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-和-的区别是什么" aria-hidden="true">#</a> 1.#{}和\${}的区别是什么？</h3><ul><li><code>\${}</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如\${driver}会被静态替换为<code>com.mysql.jdbc. Driver</code>。</li><li><code>#{}</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#{}</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#{item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li></ul><h3 id="_2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" tabindex="-1"><a class="header-anchor" href="#_2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" aria-hidden="true">#</a> 2.Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h3><p>还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p><h3 id="_3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#_3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> 3.通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ， 在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p><p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复。<strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回</p><h3 id="_4-mybatis-是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#_4-mybatis-是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> 4.MyBatis 是如何进行分页的？分页插件的原理是什么？</h3><p><strong>(1)</strong> MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；</p><p><strong>(2)</strong> 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能;</p><p><strong>(3)</strong> 也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例： <code>select _ from student</code> ，拦截 sql 后重写为： <code>select t._ from （select \\* from student）t limit 0，10</code></p><h3 id="_5-说说mybatis的缓存机制" tabindex="-1"><a class="header-anchor" href="#_5-说说mybatis的缓存机制" aria-hidden="true">#</a> 5.说说Mybatis的缓存机制:</h3><p>Mybatis整体：<img src="https://minio.pigx.top/oss/2022/07/tB17CF.png" alt="" loading="lazy"></p><p>一级缓存localCache</p><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的 SQL， MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存， 避免直接对数据库进行查询，提高性能。 每个 SqlSession 中持有了 Executor，每个 Executor 中有一个 LocalCache。当用户发起查询时， MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，如果缓存命中 的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 Local Cache，最后 返回结果给用户。具体实现类的类关系图如下图所示：</p><figure><img src="https://minio.pigx.top/oss/2022/07/wh5Lie.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>MyBatis 一级缓存的生命周期和 SqlSession 一致。</p></li><li><p>MyBatis 一级缓存内部设计简单，只是一个没有容量限定的 HashMap，在缓存的功能性上有 所欠缺。</p></li><li><p>MyBatis 的一级缓存最大范围是 SqlSession 内部，有多个 SqlSession 或者分布式的环境下， 数据库写操作会引起脏数据，建议设定缓存级别为 Statement。</p></li></ol><p>二级缓存</p><p>在上文中提到的一级缓存中，其最大的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询，具体的工作 流程如下所示。</p><figure><img src="https://minio.pigx.top/oss/2022/07/7pixkg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>二级缓存开启后，同一个 namespace 下的所有操作语句，都影响着同一个 Cache，即二级缓存被 多个 SqlSession 共享，是一个全局的变量。</p><p>当开启缓存后，数据的查询执行的流程为：</p><p>二级缓存 -&gt; 一级缓存 -&gt; 数据库</p><ol><li><p>MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时粒度 更加细，能够到 namespace 级别，通过 Cache 接口实现类不同的组合，对 Cache 的可控性 也更强。</p></li><li><p>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件 比较苛刻。</p></li><li><p>在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现 读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直 接使用 Redis、Memcached 等分布式缓存可能成本更低，安全性也更高。</p></li></ol><h3 id="_6-什么是-mybatis" tabindex="-1"><a class="header-anchor" href="#_6-什么是-mybatis" aria-hidden="true">#</a> 6.什么是 Mybatis？</h3><p>1、Mybatis 是一个半 ORM（对象关系映射）框架， 它内部封装了 JDBC， 开发时 只需要关注 SQL 语句本身， 不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 程序员直接编写原生态 sql， 可以严格控制 sql 执行性 能， 灵活度高。</p><p>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息， 将 POJO 映射成数 据库中的记录， 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来， 并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句， 最 后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 （从执行 sql 到返 回 result 的过程）。</p><h3 id="_7-mybatis-编程步骤" tabindex="-1"><a class="header-anchor" href="#_7-mybatis-编程步骤" aria-hidden="true">#</a> 7.MyBatis 编程步骤</h3><ol><li>创建 SqlSessionFactory 对象。</li><li>通过 SqlSessionFactory 获取 SqlSession 对象。</li><li>通过 SqlSession 获得 Mapper 代理对象。</li><li>通过 Mapper 代理对象，执行数据库操作。</li><li>执行成功，则使用 SqlSession 提交事务。</li><li>执行失败，则使用 SqlSession 回滚事务。</li><li>最终，关闭会话。</li></ol><h3 id="_8-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理吗" tabindex="-1"><a class="header-anchor" href="#_8-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理吗" aria-hidden="true">#</a> 8.Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h3><ul><li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li><li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li><li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li></ul><h3 id="_9-通常一个-xml-映射文件-都会写一个-mapper-接口与之对应。请问-这个-mapper-接口的工作原理是什么-mapper-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#_9-通常一个-xml-映射文件-都会写一个-mapper-接口与之对应。请问-这个-mapper-接口的工作原理是什么-mapper-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> 9.通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h3><p>Mapper 接口，对应的关系如下：</p><ul><li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li><li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li><li>接口方法内的参数，就是传递给 SQL 的参数。</li></ul><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p><p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p><p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/09/pEe3NR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_10-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_10-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" aria-hidden="true">#</a> 10.Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p><ul><li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map&lt;String, Statement&gt;</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li><li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li></ul><hr><p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p><p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p><h3 id="_11-mybatis-如何执行批量插入" tabindex="-1"><a class="header-anchor" href="#_11-mybatis-如何执行批量插入" aria-hidden="true">#</a> 11.MyBatis 如何执行批量插入?</h3><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;String&quot;&gt; 
    INSERT INTO users(name) 
    VALUES (#{value}) 
&lt;/insert&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public interface UserMapper {
    
    void insertUser(@Param(&quot;name&quot;) String name);

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，调用该 Mapper 接口方法。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>private static SqlSessionFactory sqlSessionFactory;

@Test
public void testBatch() {
    // 创建要插入的用户的名字的数组
    List&lt;String&gt; names = new ArrayList&lt;&gt;();
    names.add(&quot;占小狼&quot;);
    names.add(&quot;朱小厮&quot;);
    names.add(&quot;徐妈&quot;);
    names.add(&quot;飞哥&quot;);

    // 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动提交
    try (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH, false)) {
        // 获得 Mapper 对象
        UserMapper mapper = session.getMapper(UserMapper.class);
        // 循环插入
        for (String name : names) {
            mapper.insertUser(name);
        }
        // 提交批量操作
        session.commit();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>INSERT INTO [表名]([列名],[列名]) 
VALUES
([列值],[列值])),
([列值],[列值])),
([列值],[列值]));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M</li></ul><h3 id="_12-mybatis-映射文件中-如果-a-标签通过-include-引用了b标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在a标签的前面" tabindex="-1"><a class="header-anchor" href="#_12-mybatis-映射文件中-如果-a-标签通过-include-引用了b标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在a标签的前面" aria-hidden="true">#</a> 12.Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p><p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h3 id="_13-mybatis缓存模块" tabindex="-1"><a class="header-anchor" href="#_13-mybatis缓存模块" aria-hidden="true">#</a> 13.mybatis缓存模块</h3><p>MyBatis 中提供了<strong>一级缓存和二级缓存</strong>，而这两级缓存都是依赖于基础支持层中的缓 存模块实现的。这里需要读者注意的是，MyBatis 中自带的这两级缓存与 MyBatis 以及整个应用是运行在同一个 JVM 中的，共享同一块堆内存。如果这两级缓存中的数据量较大， 则可能影响系统中其他功能的运行，所以当需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p><h3 id="_14-mybatis-sql执行整体过程" tabindex="-1"><a class="header-anchor" href="#_14-mybatis-sql执行整体过程" aria-hidden="true">#</a> 14.mybatis sql执行整体过程</h3><p>SQL 语句的执行涉及多个组件 ，其中比较重要的是 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 。</p><ul><li><strong>Executor</strong> 主要负责维护一级缓存和二级缓存，并提供事务管理的相关操作，它会将数据库相关操作委托给 StatementHandler完成。</li><li><strong>StatementHandler</strong> 首先通过 <strong>ParameterHandler</strong> 完成 SQL 语句的实参绑定，然后通过 <code>java.sql.Statement</code> 对象执行 SQL 语句并得到结果集，最后通过 <strong>ResultSetHandler</strong> 完成结果集的映射，得到结果对象并返回。</li></ul><p>整体过程如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/09/gxAZVB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_15-mybatis连接池添加连接与获取连接" tabindex="-1"><a class="header-anchor" href="#_15-mybatis连接池添加连接与获取连接" aria-hidden="true">#</a> 15.mybatis连接池添加连接与获取连接</h3><figure><img src="https://minio.pigx.top/oss/2022/09/f4ElMj.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/09/aSHcID.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_16-什么是mybatis一级缓存、二级缓存" tabindex="-1"><a class="header-anchor" href="#_16-什么是mybatis一级缓存、二级缓存" aria-hidden="true">#</a> 16.什么是mybatis一级缓存、二级缓存</h3><p>每当我们使用 MyBatis 开启一次和数据库的会话，MyBatis 会创建出一个 SqlSession 对象表示一次数据库会话，<strong>而每个 SqlSession 都会创建一个 Executor 对象</strong>。</p><p>在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库，而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。</p><p>为了解决这一问题，减少资源的浪费，MyBatis 会在表示会话的SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。 <strong>注意，这个“简单的缓存”就是一级缓存，且默认开启，无法关闭</strong>。</p><p>如下图所示，MyBatis 会在一次会话的表示 —— 一个 SqlSession 对象中创建一个本地缓存( <code>localCache</code> )，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</p><figure><img src="https://minio.pigx.top/oss/2022/09/0d6h3n.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上文中提到的一级缓存中，<strong>其最大的共享范围就是一个 SqlSession 内部</strong>，如果多个 SqlSession 之间需要共享缓存，则需要使用到<strong>二级缓存</strong>。开启二级缓存后，会使用 CachingExecutor 装饰 Executor ，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。</p><figure><img src="https://minio.pigx.top/oss/2022/09/hAA7PF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_17-batchexecutor" tabindex="-1"><a class="header-anchor" href="#_17-batchexecutor" aria-hidden="true">#</a> 17.BatchExecutor</h3><p>BatchExecutor ，继承 BaseExecutor 抽象类，批量执行的 Executor 实现类。</p><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</p><h3 id="_18-jdbc编程步骤" tabindex="-1"><a class="header-anchor" href="#_18-jdbc编程步骤" aria-hidden="true">#</a> 18.jdbc编程步骤</h3><p>一、注册驱动</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//类加载注册</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>二、获取连接</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;用户名&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;密码&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>三、获取数据库操作对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>四、设置传入参数</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>五、执行sql语句</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">&quot;select * from userinfo where user_id=?&quot;</span><span class="token punctuation">;</span>
  rs <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>六、处理查询结果集</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token class-name">String</span> name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;first_name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">String</span> money <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;salary&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">String</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;job_id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> money <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>七、释放资源</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">if</span><span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://minio.pigx.top/oss/2022/09/BhYm3a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,99),o=[i];function c(p,l){return n(),s("div",null,o)}const r=a(t,[["render",c],["__file","06-mybatis.html.vue"]]);export{r as default};
