import{_ as e,V as i,W as a,$ as n}from"./framework-159025ca.js";const t={},r=n(`<h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h1><h3 id="_1-面向对象编程中-都有哪些设计原则" tabindex="-1"><a class="header-anchor" href="#_1-面向对象编程中-都有哪些设计原则" aria-hidden="true">#</a> 1.面向对象编程中，都有哪些设计原则</h3><ol><li><p>开闭原则 对扩展开放，对修改关闭。就是如果要修改原有的功能或者是扩展功能，尽量去扩展原有的代码，而不是修改原来已有的代码。</p></li><li><p>里氏替换原则 任何子类对象都应该可以替换其派生的超类对象 。即子类可以扩展父类的功能，但不要修改父类原有的功能。 也就是说，当一个子类继承父类后，尽量不要去重写它原有的方法。</p></li><li><p>依赖转置（依赖倒置）原则 要面向接口编程，不要面向实现编程。两个模块交互时，都访问各自接口，而不是具体的实现类。</p></li><li><p>单一职责原则 一个对象要专注于一种事情，不要让它担任太多责任。</p></li><li><p>接口隔离原则 一个接口尽量只包含用户关心的内容。就是一个接口不要太庞大。</p></li><li><p>迪米特法则 如果两个软件实体之间不是特别必要，尽量不要让他们直接通信。而是找个第三方进行转发，比如使用MQ（消息队列）。</p></li><li><p>合成复用原则 如果在“组合/聚合”和“继承”之间做抉择时，优先选择“组合/聚合”。</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/tiN4Rk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-设计模式的分类" tabindex="-1"><a class="header-anchor" href="#_2-设计模式的分类" aria-hidden="true">#</a> 2.设计模式的分类</h3><p>设计模式分为：</p><p><strong>创建型模式</strong>：</p><pre><code>用于创建对象的设计模式。一般可以简化用户创建对象的过程。其次可以降低耦合度，用户不需要关心对象具体的创建过程。
包含：单例模式、原型模型、工厂模式、建造者模式
</code></pre><p><strong>结构型模型</strong>：</p><pre><code>组织对象之间的结构。使其易于扩展等。通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。
包括：代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式、组合模式。
</code></pre><p><strong>行为模型</strong>：</p><pre><code>主要用于决定对象如何做出行为
包括：模板方法模式、策略模式、命令模式、责任链、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式。
</code></pre><h3 id="_3-你知道哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_3-你知道哪些设计模式" aria-hidden="true">#</a> 3.你知道哪些设计模式？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/5I6vTQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,14),o=[r];function p(d,s){return i(),a("div",null,o)}const l=e(t,[["render",p],["__file","12-design-pattern.html.vue"]]);export{l as default};
