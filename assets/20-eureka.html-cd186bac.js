import{_ as e,V as r,W as a,$ as n}from"./framework-159025ca.js";const t={},s=n('<h1 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka" aria-hidden="true">#</a> Eureka</h1><h3 id="_1-eureka-server-数据存储" tabindex="-1"><a class="header-anchor" href="#_1-eureka-server-数据存储" aria-hidden="true">#</a> 1.Eureka Server 数据存储</h3><p>Eureka Server 的数据存储分了二层：<strong>数据层和缓存层</strong> 数据层记录的是注册到Eureka Server 上的服务信息，缓存层记录包装以后的数据，可以直接在 Eureka Client 调用时返回。 Eureka Server 的数据层是<strong>二层 ConcurrentHashMap</strong>， ConcurrentHashMap 是线程安全高效的 Map 集合。 第一层的 ConcurrentHashMap 的 key=spring.application.name也就是客户端实例注册的应用名。 第二层嵌套的 ConcurrentHashMap 的 key=instanceId 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。 根据这个存储结构我们可以发现，Eureka Server 第一层都是存储着所有的服务名，以及服务名对应的实例信息</p><p><strong>Eureka Server 缓存机制</strong></p><p>Eureka Server 为了提供响应效率，提供了两层的缓存结构，将 Eureka Client 所需要的注册信息，直接存储在缓存结构中。 第一层缓存：readOnlyCacheMap，本质上是 ConcurrentHashMap，依赖定时从 readWriteCacheMap 同步数据，默认时间为 30 秒。 readOnlyCacheMap ： 是一个 CurrentHashMap 只读缓存，这个主要是为了供客户端获取注册信息时使用，其缓存更新，依赖于定时器的更新，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。 第二层缓存：readWriteCacheMap，本质上是 Guava 缓存。 eadWriteCacheMap：readWriteCacheMap 的数据主要同步存储层的数据，当请求获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。 readWriteCacheMap 缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。 Eureka Client 获取全量或者增量的数据时，会先从一级缓存中获取；如果一级缓存中不存在，再从二级缓存中获取；如果二级缓存也不存在，这时候先将存储层的数据同步到缓存中，再从缓存中获取。</p><p>通过 Eureka Server 的二层缓存机制，可以非常有效地提升 Eureka Server 的响应时间，通过数据存储层和缓存层的数据切割，根据使用场景来提供不同的数据支持。</p><p><strong>其它缓存设计</strong></p><p>Eureka Server 端存在缓存外，Eureka Client 也同样存在着缓存机制，Eureka Client <strong>启动时会全量拉取服务列表</strong>，启动后每隔 30 秒从 Eureka Server 增量获取服务列表信息，并保持在本地缓存中。</p><p>Eureka Client 增量拉取失败，或者增量拉取之后对比 hashcode 发现不一致，就会执行全量拉取，这样避免了网络某时段分片带来的问题，同样会更新到本地缓存。 同时对于服务调用，如果涉及到 ribbon 负载均衡，那么 ribbon 对于这个实例列表也有自己的缓存，这个缓存定时(默认30秒)从 Eureka Client 的缓存更新。 这么多的缓存机制可能就会造成一些问题，一个服务启动后可能最长需要 90s 才能被其它服务感知到: 1、首先，Eureka Server 维护每 30s 更新的响应缓存</p><p>2、Eureka Client 对已经获取到的注册信息也做了 30s 缓存</p><p>3、负载均衡组件 Ribbon 也有 30s 缓存</p><p>这三个缓存加起来，就有可能导致服务注册最长延迟 90s ，这个需要我们在特殊业务场景中注意其产生的影响。</p>',12),p=[s];function u(i,o){return r(),a("div",null,p)}const h=e(t,[["render",u],["__file","20-eureka.html.vue"]]);export{h as default};
