import{_ as o,V as t,W as l,X as e,Y as n,Z as s,$ as r,F as d}from"./framework-159025ca.js";const a={},c=r('<h1 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> redis持久化</h1><p>Redis 提供了3种持久化机制来保证数据在断电或重启后不会丢失：</p><ul><li>快照（snapshotting，RDB）: RDB 以指定的时间间隔执行数据集的时间点快照。</li><li>只追加文件（append-only file, AOF）: AOF 持久性记录服务器接收到的每个写操作。然后可以在服务器启动时再次重播这些操作，从而重建原始数据集。命令使用与 Redis 协议本身相同的格式进行记录。</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><h2 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h2><h3 id="怎么运行" tabindex="-1"><a class="header-anchor" href="#怎么运行" aria-hidden="true">#</a> 怎么运行</h3><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li><li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li></ul><p>每当 Redis 需要将数据集转储到磁盘时，就会发生以下情况：</p>',8),h={href:"http://linux.die.net/man/2/fork",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,"子进程开始将数据集写入临时 RDB 文件。",-1),u=e("li",null,"当子进程写完新的 RDB 文件后，它会替换旧的 RDB 文件（Copy-on-Write）。",-1),f=r('<figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/15/zqDdhA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>RDB 文件非常适合备份。例如，您可能希望在最近 24 小时内每小时归档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松<strong>恢复不同版本</strong>的数据集。</li><li>RDB 非常适合灾难恢复，它是一个<strong>紧凑</strong>的文件，可以传输到远程数据中心或 Amazon S3（可能是加密的）。</li><li>RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化需要做的唯一工作就是<strong>派生一个子进程</strong>，该子进程将完成其余所有工作。父进程永远不会执行磁盘 I/O 或类似操作。</li><li>与 AOF 相比，RDB 允许<strong>更快</strong>地重新启动大数据集。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li>如果您需要在 Redis 停止工作（例如断电后）时最大程度地减少数据丢失的可能性，那么 RDB 并不好。您可以在生成 RDB 的位置配置不同的<em>保存点</em>（例如，在<strong>至少五分钟并对数据集进行 100 次写入后</strong>）。但是，您通常会每五分钟或更长时间创建一个 RDB 快照，因此，如果 Redis 由于任何原因在没有正确关闭的情况下停止工作，您应该做好丢失最新分钟数据的准备。</li><li>RDB 需要经常 fork() 才能使用子进程持久保存在磁盘上。如果数据集很大，fork() 可能会非常耗时，并且如果数据集很大并且 CPU 性能不是很好，可能会导致 Redis 停止为客户端提供服务几毫秒甚至一秒。AOF 还需要 fork() 但频率较低，您可以调整重写日志的频率，而无需牺牲持久性。</li></ul><h2 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h2><h3 id="怎么运行-1" tabindex="-1"><a class="header-anchor" href="#怎么运行-1" aria-hidden="true">#</a> 怎么运行</h3>',7),p={href:"https://redis.io/commands/set",target:"_blank",rel:"noopener noreferrer"},R=e("code",null,"SET",-1),g=e("strong",null,"多部分AOF机制",-1),A={href:"https://redis.io/docs/management/persistence/#log-rewriting",target:"_blank",rel:"noopener noreferrer"},F=r('<p><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</p><p><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</p><p><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</p><p><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</p><p><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p><h3 id="日志重写" tabindex="-1"><a class="header-anchor" href="#日志重写" aria-hidden="true">#</a> 日志重写</h3><p>随着写操作的执行，AOF 会变得越来越大。例如，如果您将计数器递增 100 次，则最终数据集中会出现一个包含最终值的键，但 AOF 中会出现 100 个条目。其中 99 个条目不需要重建当前状态。</p><p>重写是完全安全的。当 Redis 继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换这两个文件并开始追加到新文件。</p>',8),O={href:"https://redis.io/commands/bgrewriteaof",target:"_blank",rel:"noopener noreferrer"},B=e("code",null,"BGREWRITEAOF",-1),m={href:"https://redis.io/commands/bgrewriteaof",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"BGREWRITEAOF",-1),D=e("p",null,"**从Redis 7.0.0开始，当计划进行AOF重写时，Redis父进程会打开一个新的增量AOF文件来继续写入。子进程执行重写逻辑并生成新的基础 AOF。**Redis将使用临时清单文件来跟踪新生成的基础文件和增量文件。当它们准备好时，Redis将执行原子替换操作以使这个临时清单文件生效。为了避免 AOF 重写重复失败和重试时创建大量增量文件的问题，Redis 引入了 AOF 重写限制机制，以确保失败的 AOF 重写以越来越慢的速度重试。",-1),x=e("p",null,[e("strong",null,"Redis >= 7.0")],-1),k={href:"http://linux.die.net/man/2/fork",target:"_blank",rel:"noopener noreferrer"},y=e("li",null,"子进程开始在临时文件中写入新的基本 AOF。",-1),z=e("li",null,"父级打开一个新的增量 AOF 文件以继续写入更新。如果重写失败，旧的基本文件和增量文件（如果有）加上这个新打开的增量文件就代表了完整的更新数据集，所以我们是安全的。",-1),E=e("li",null,"当子进程完成重写基本文件时，父进程收到一个信号，并使用新打开的增量文件和子进程生成的基本文件来构建临时清单，并将其保留。",-1),v=e("li",null,"Redis 对清单文件进行原子交换，以便 AOF 重写的结果生效。Redis 还会清理旧的基本文件和任何未使用的增量文件。",-1),w=e("p",null,[e("strong",null,"Redis < 7.0")],-1),L={href:"http://linux.die.net/man/2/fork",target:"_blank",rel:"noopener noreferrer"},I=e("li",null,"子进程开始在临时文件中写入新的 AOF。",-1),V=e("li",null,"父级将所有新更改累积在内存缓冲区中（但同时它将新更改写入旧的仅追加文件中，因此如果重写失败，我们是安全的）。",-1),N=e("li",null,"当子进程重写完文件后，父进程会收到一个信号，并将内存缓冲区附加到子进程生成的文件的末尾。",-1),S=e("li",null,"现在，Redis 以原子方式将新文件重命名为旧文件，并开始将新数据附加到新文件中。",-1),T=e("h3",{id:"优点-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#优点-1","aria-hidden":"true"},"#"),n(" 优点")],-1),W=e("li",null,[n("您可以有"),e("strong",null,"不同的 fsync 策略"),n("：根本不进行 fsync、每秒进行 fsync、每次查询时进行 fsync。采用每秒fsync的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此您只能"),e("strong",null,"丢失一秒钟"),n("的写入。")],-1),C=e("li",null,"AOF 日志是仅追加日志，因此不会出现查找问题，并且在断电时也不会出现损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以半写命令结束，redis-check-aof 工具也能够轻松修复它。",-1),j=e("li",null,[n("当 AOF 太大时，Redis 能够在"),e("strong",null,"后台自动重写 AOF"),n("。重写是完全安全的，因为当 Redis 继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会"),e("strong",null,"切换这两个文件并开始追加到新的那一个"),n("。")],-1),G={href:"https://redis.io/commands/flushall",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"FLUSHALL",-1),U=r('<h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h3><ul><li>对于相同的数据集，<strong>AOF 文件通常比等效的 RDB 文件大。</strong></li><li>AOF 可能比 RDB 慢，具体取决于确切的 fsync 策略。一般来说，将 fsync 设置为<em>每秒一次的</em>性能仍然非常高，并且禁用 fsync 后，即使在高负载下，它也应该与 RDB 一样快。即使在巨大的写入负载的情况下，RDB仍然能够对最大延迟提供更多的保证。</li></ul><p><strong>Redis &lt; 7.0</strong></p><ul><li>如果在重写期间对数据库进行写入（这些内容会缓冲在内存中并在最后写入新的 AOF），则 AOF 可能会使用大量内存。</li><li>重写期间到达的所有写入命令都会写入磁盘两次。</li><li>Redis 在重写结束时冻结写入并将这些写入命令同步到新的 AOF 文件。因此可能会导致一段时间内的数据持久化能力下降。</li></ul><h2 id="混合持久化" tabindex="-1"><a class="header-anchor" href="#混合持久化" aria-hidden="true">#</a> 混合持久化</h2><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h2 id="从持久化文件恢复数据" tabindex="-1"><a class="header-anchor" href="#从持久化文件恢复数据" aria-hidden="true">#</a> 从持久化文件恢复数据</h2><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/r90Lae.png" alt="恢复数据" tabindex="0" loading="lazy"><figcaption>恢复数据</figcaption></figure><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p>',11);function q(H,X){const i=d("ExternalLinkIcon");return t(),l("div",null,[c,e("ul",null,[e("li",null,[n("Redis "),e("a",h,[n("fork"),s(i)]),n("子进程。我们现在有一个子进程和一个父进程。")]),_,u]),f,e("p",null,[n("Redis 6.0 之后已经默认是开启了AOF，每次 Redis 收到更改数据集的命令（例如"),e("a",p,[R,s(i)]),n("）时，它都会将其追加到 AOF 中。当您重新启动 Redis 时，它将重放 AOF 以重建状态。")]),e("p",null,[n("从Redis 7.0.0开始，Redis使用"),g,n("。即把原来的单个AOF文件拆分为基础文件（最多一个）和增量文件（可能不止一个）。基础文件表示重写 AOF 时存在的数据的初始（RDB 或 AOF 格式）"),e("a",A,[n("快照"),s(i)]),n("。增量文件包含自上次创建基本 AOF 文件以来的增量更改。所有这些文件都放在单独的目录中，并由清单文件跟踪。")]),F,e("p",null,[n("因此，Redis 支持一个有趣的功能：它能够在后台重建 AOF，而不会中断对客户端的服务。每当您发出 时"),e("a",O,[B,s(i)]),n("，Redis 都会写入在内存中重建当前数据集所需的最短命令序列。如果您将 AOF 与 Redis 2.2 一起使用，则需要"),e("a",m,[b,s(i)]),n("不时运行。由于Redis 2.4能够自动触发日志重写（更多信息请参见示例配置文件）。")]),D,x,e("ul",null,[e("li",null,[n("Redis "),e("a",k,[n("fork子进程"),s(i)]),n("，所以现在我们有一个子进程和一个父进程。")]),y,z,E,v]),w,e("ul",null,[e("li",null,[n("Redis"),e("a",L,[n("fork子进程"),s(i)]),n("，所以现在我们有一个子进程和一个父进程。")]),I,V,N,S]),T,e("ul",null,[W,C,j,e("li",null,[n("AOF 以一种易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出 AOF 文件。例如，即使您不小心使用该"),e("a",G,[P,s(i)]),n("命令刷新了所有内容，只要在此期间没有执行日志重写，您仍然可以通过停止服务器、删除最新命令并再次重新启动 Redis 来保存数据集。")])]),U])}const Z=o(a,[["render",q],["__file","redis-persistence.html.vue"]]);export{Z as default};
