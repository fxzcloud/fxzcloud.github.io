import{_ as s,V as i,W as l,X as e,Z as o,Y as n,$ as t,F as d}from"./framework-159025ca.js";const a={},c=t('<h1 id="redis常见数据类型" tabindex="-1"><a class="header-anchor" href="#redis常见数据类型" aria-hidden="true">#</a> redis常见数据类型</h1><h3 id="streams-流" tabindex="-1"><a class="header-anchor" href="#streams-流" aria-hidden="true">#</a> streams(流)</h3><p>Redis 流是一种数据结构，其作用类似于仅追加日志，但也实现了多种操作来克服典型仅追加日志的一些限制。其中包括 O(1) 时间内的随机访问和复杂的消费策略，例如消费者组。</p><p>使用场景：</p><ul><li>事件溯源（例如，跟踪用户操作、点击等）</li><li>传感器监控（例如，现场设备的读数）</li><li>通知（例如，将每个用户的通知记录存储在单独的流中）</li><li>消息队列</li></ul><p>Redis 为每个流条目生成一个唯一的 ID。可以使用这些 ID 稍后检索其关联条目或读取并处理流中的所有后续条目。</p><h4 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h4>',7),h={href:"https://redis.io/commands/xadd",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"XADD",-1),p={href:"https://redis.io/commands/xread",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"XREAD",-1),m={href:"https://redis.io/commands/xrange",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"XRANGE",-1),f={href:"https://redis.io/commands/xlen",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"XLEN",-1),v={href:"https://redis.io/commands/?group=stream",target:"_blank",rel:"noopener noreferrer"},x=t(`<p>向race:france添加一条数据，*表示id自动生成，后面是对象的属性和属性值。</p><div class="language-te line-numbers-mode" data-ext="te"><pre class="language-te"><code> XADD race:france * rider Castilla speed 29.9 position 1 location_id 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/YUzX6j.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>命令返回的条目 ID 明确地标识给定流中的每个条目，由两部分组成：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;</span>millisecondsTime<span class="token operator">&gt;</span>-<span class="token operator">&lt;</span>sequenceNumber<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>毫秒时间部分实际上是生成流ID的本地Redis节点中的本地时间，但是如果当前毫秒时间恰好小于前一个条目时间，则使用前一个条目时间，因此如果时钟向后跳单调递增的 ID 属性仍然成立。序列号用于在同一毫秒内创建的条目。由于序列号是64位宽，因此实际上同一毫秒内可以生成的条目数量没有限制。</p><h4 id="消费者组" tabindex="-1"><a class="header-anchor" href="#消费者组" aria-hidden="true">#</a> 消费者组</h4><p>消费者组就像一个<em>伪消费者</em>，从流中获取数据，实际上为多个消费者提供服务，提供一定的保证：</p><ol><li>每条消息都提供给不同的消费者，因此同一条消息不可能传递给多个消费者。</li><li>消费者在消费者组中通过名称来标识，该名称是实现消费者的客户端必须选择的区分大小写的字符串。这意味着即使在断开连接后，流消费者组仍保留所有状态，因为客户端将再次声明自己是同一个消费者。然而，这也意味着客户端需要提供唯一的标识符。</li><li><em>每个消费者组都有第一个从未消费过的 ID</em>的概念，这样，当消费者请求新消息时，它可以只提供之前未传递的消息。</li><li>使用消息需要使用特定命令进行ack显式确认。Redis 将确认解释为：此消息已正确处理，因此可以将其从消费者组中逐出。</li><li>消费者组跟踪当前待处理的所有消息，即已传递给消费者组的某个消费者但尚未确认已处理的消息。由于此功能，当访问流的消息历史记录时，每个消费者<em>只会看到传递给它的消息</em>。</li></ol><p>在某种程度上，消费者组可以被想象成关于流的某种<em>状态：</em></p><div class="language-te line-numbers-mode" data-ext="te"><pre class="language-te"><code>+----------------------------------------+
| consumer_group_name: mygroup           |
| consumer_group_stream: somekey         |
| last_delivered_id: 1292309234234-92    |
|                                        |
| consumers:                             |
|    &quot;consumer-1&quot; with pending messages  |
|       1292309234234-4                  |
|       1292309234232-8                  |
|    &quot;consumer-42&quot; with pending messages |
|       ... (and so forth)               |
+----------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您从这个角度来看这一点，就很容易理解消费者组可以做什么，它如何能够向消费者提供其待处理消息的历史记录，以及如何为请求新消息的消费者提供服务消息 ID 大于<code>last_delivered_id</code>.</p><p>现在是时候放大看看基本的消费者组命令了。它们是：</p>`,13),k={href:"https://redis.io/commands/xgroup",target:"_blank",rel:"noopener noreferrer"},D=e("code",null,"XGROUP",-1),I={href:"https://redis.io/commands/xreadgroup",target:"_blank",rel:"noopener noreferrer"},R=e("code",null,"XREADGROUP",-1),E={href:"https://redis.io/commands/xack",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"XACK",-1),y=t(`<p>为流race:italy，创建一个消费者组叫italy_riders，$表示表示当前流中最大的id，即为消费者组中的消费者提供新的消息。MKSTREAM表示不存在则创建流。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>XGROUP CREATE race:italy italy_riders $ MKSTREAM
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用XADD为流创建几条数据。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> XADD race:italy * rider Castilla
 XADD race:italy * rider Royce
 XADD race:italy * rider Sam-Bodden
 XADD race:italy * rider Prickett
 XADD race:italy * rider Norem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用XREADGROUP命令，为italy_riders组中的Alice读取一条数据。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy &gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果 ID 是特殊 ID <code>&gt;</code>，则该命令将仅返回迄今为止从未传递给其他消费者的新消息，并且作为副作用，将更新消费者组的<em>最后一个 ID</em>。</li><li>如果 ID 是任何其他有效的数字 ID，那么该命令将允许我们访问<em>待处理消息的历史记录</em>。也就是说，传递给此指定使用者（由提供的名称标识）且迄今为止从未通过 XACK确认的消息集。</li></ul><p>可以看到xadd创建的数据。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/JjAbph.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到消费者组的信息，其中italy_riders有一个消费者，有一条待处理消息。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/3AmRo7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/Yoo4uo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/rwbdvB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>XACK race:italy italy_riders 1710417175164-0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行完XACK，待处理消息没了。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/wyu6LK.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/14/lmkvJ1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="流-api-中的特殊-id" tabindex="-1"><a class="header-anchor" href="#流-api-中的特殊-id" aria-hidden="true">#</a> 流 API 中的特殊 ID</h4><p>有几个特殊的 ID 可以在 Redis API 中使用。</p>`,19),T=e("code",null,"-",-1),z=e("code",null,"+",-1),L={href:"https://redis.io/commands/xrange",target:"_blank",rel:"noopener noreferrer"},O=e("code",null,"XRANGE",-1),X=e("code",null,"0-1",-1),P=e("code",null,"18446744073709551615-18446744073709551615",-1),N=t("<p>然后还有我们想要说的 API，即流中 ID 最大的项目的 ID。这就是这个<code>$</code>意思。当我创建或设置消费者组的 ID 时，我可以将最后交付的项目设置为 ，<code>$</code>以便仅向该组中的消费者交付新条目。</p><p><code>$</code>并不意味着<code>+</code>，它们是两个不同的东西，因为<code>+</code>是每个可能的流中可能的最大 ID，而<code>$</code>是包含给定条目的给定流中的最大 ID。</p>",2),B=e("code",null,">",-1),S={href:"https://redis.io/commands/xreadgroup",target:"_blank",rel:"noopener noreferrer"},G=e("code",null,"XREADGROUP",-1),C=e("code",null,">",-1),M=e("em",null,"最后交付的ID 。",-1),U=e("code",null,"*",-1),H={href:"https://redis.io/commands/xadd",target:"_blank",rel:"noopener noreferrer"},j=e("code",null,"XADD",-1),K=t('<p>所以我们有<code>-</code>、<code>+</code>、<code>$</code>、<code>&gt;</code>和<code>*</code>，并且都有不同的含义，并且大多数时候，可以在不同的上下文中使用。</p><h3 id="bitmaps-位图" tabindex="-1"><a class="header-anchor" href="#bitmaps-位图" aria-hidden="true">#</a> bitmaps(位图)</h3><p>可以看成是一个01字符串。</p><p>使用场景：</p><ul><li>用户连续登录、签到。</li></ul><h4 id="常用命令-1" tabindex="-1"><a class="header-anchor" href="#常用命令-1" aria-hidden="true">#</a> 常用命令</h4>',6),V={href:"https://redis.io/commands/setbit",target:"_blank",rel:"noopener noreferrer"},F=e("code",null,"SETBIT",-1),$={href:"https://redis.io/commands/getbit",target:"_blank",rel:"noopener noreferrer"},Y=e("code",null,"GETBIT",-1),q={href:"https://redis.io/commands/bitop",target:"_blank",rel:"noopener noreferrer"},Z=e("code",null,"BITOP",-1),w={href:"https://redis.io/commands/bitcount",target:"_blank",rel:"noopener noreferrer"},J=e("code",null,"BITCOUNT",-1),W={href:"https://redis.io/commands/bitpos",target:"_blank",rel:"noopener noreferrer"},Q=e("code",null,"BITPOS",-1),ee={href:"https://redis.io/commands/setbit",target:"_blank",rel:"noopener noreferrer"},ne=e("code",null,"SETBIT",-1),re={href:"https://redis.io/commands/getbit",target:"_blank",rel:"noopener noreferrer"},oe=e("code",null,"GETBIT",-1),te={href:"https://redis.io/commands/bitop",target:"_blank",rel:"noopener noreferrer"},se=e("code",null,"BITOP",-1),ie=e("em",null,"n",-1),le=e("h3",{id:"bitfields-位域",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#bitfields-位域","aria-hidden":"true"},"#"),n(" bitfields(位域)")],-1),de=e("p",null,"Redis 位域允许您设置、递增和获取任意位长度的整数值。",-1),ae=e("p",null,"例如，您可以操作从无符号 1 位整数到有符号 63 位整数的任何值。",-1),ce=e("p",null,"这些值使用二进制编码的 Redis 字符串存储。位域支持原子读、写和增量操作，使它们成为管理计数器和类似数值的不错选择。",-1),he=e("h4",{id:"基本命令",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#基本命令","aria-hidden":"true"},"#"),n(" 基本命令")],-1),_e={href:"https://redis.io/commands/bitfield",target:"_blank",rel:"noopener noreferrer"},pe=e("code",null,"BITFIELD",-1),ue={href:"https://redis.io/commands/bitfield_ro",target:"_blank",rel:"noopener noreferrer"},me=e("code",null,"BITFIELD_RO",-1),ge={href:"https://redis.io/commands/bitfield",target:"_blank",rel:"noopener noreferrer"},fe=e("code",null,"BITFIELD",-1),be=t('<h4 id="位图和位域的区别" tabindex="-1"><a class="header-anchor" href="#位图和位域的区别" aria-hidden="true">#</a> 位图和位域的区别</h4><p>位图适用于简单的位操作和状态标记，例如用户签到。而位域则更适用于需要对不同位段进行复杂操作的场景。</p><p>位图可以看成是一个01字符串，进行状态标识。</p><p>位域可以看成是一个整型数组，更多的是进行位运算。</p><h3 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> hyperLogLog</h3><p>在统计大规模数据集中的唯一元素数量时非常有用。</p><p>使用场景：</p><p>统计页面访问量、点赞数量。</p><h4 id="常用命令-2" tabindex="-1"><a class="header-anchor" href="#常用命令-2" aria-hidden="true">#</a> 常用命令</h4><ol><li>PFADD：将一个或多个元素添加到 HyperLogLog 中。</li><li>PFCOUNT ：返回给定 HyperLogLog 的基数估算值（即不同元素的数量）。</li><li>PFMERGE：将多个 HyperLogLog 合并为一个 HyperLogLog。</li></ol><h3 id="geospatial-地理空间" tabindex="-1"><a class="header-anchor" href="#geospatial-地理空间" aria-hidden="true">#</a> geospatial(地理空间)</h3><p>使用场景：</p><p>附近的人</p><h4 id="常用命令-3" tabindex="-1"><a class="header-anchor" href="#常用命令-3" aria-hidden="true">#</a> 常用命令</h4>',14),ve={href:"https://redis.io/commands/geoadd",target:"_blank",rel:"noopener noreferrer"},xe=e("code",null,"GEOADD",-1),ke={href:"https://redis.io/commands/geosearch",target:"_blank",rel:"noopener noreferrer"},De=e("code",null,"GEOSEARCH",-1),Ie=e("h3",{id:"string-字符串",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#string-字符串","aria-hidden":"true"},"#"),n(" string(字符串)")],-1),Re=e("p",null,"Redis 字符串存储字节序列，包括文本、序列化对象和二进制数组。因此，字符串是可以与 Redis 键关联的最简单的值类型。它们通常用于缓存，但它们支持附加功能，使您也可以实现计数器并执行按位运算。",-1),Ee=e("p",null,"使用场景：",-1),Ae=e("p",null,"缓存token、计数器、缓存一切。。。",-1),ye=e("h4",{id:"常用命令-4",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常用命令-4","aria-hidden":"true"},"#"),n(" 常用命令")],-1),Te={href:"https://redis.io/commands/set",target:"_blank",rel:"noopener noreferrer"},ze=e("code",null,"SET",-1),Le={href:"https://redis.io/commands/setnx",target:"_blank",rel:"noopener noreferrer"},Oe=e("code",null,"SETNX",-1),Xe={href:"https://redis.io/commands/get",target:"_blank",rel:"noopener noreferrer"},Pe=e("code",null,"GET",-1),Ne={href:"https://redis.io/commands/mget",target:"_blank",rel:"noopener noreferrer"},Be=e("code",null,"MGET",-1),Se={href:"https://redis.io/commands/incrby",target:"_blank",rel:"noopener noreferrer"},Ge=e("code",null,"INCRBY",-1),Ce={href:"https://redis.io/commands/incrbyfloat",target:"_blank",rel:"noopener noreferrer"},Me=e("code",null,"INCRBYFLOAT",-1),Ue=e("h3",{id:"list-列表",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#list-列表","aria-hidden":"true"},"#"),n(" list (列表)")],-1),He=e("p",null,"使用场景：",-1),je=e("p",null,"​ 最新发布的文章、生产者消费者模式、队列、栈。",-1),Ke=e("h4",{id:"常见命令",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常见命令","aria-hidden":"true"},"#"),n(" 常见命令")],-1),Ve={href:"https://redis.io/commands/lpush",target:"_blank",rel:"noopener noreferrer"},Fe=e("code",null,"LPUSH",-1),$e={href:"https://redis.io/commands/rpush",target:"_blank",rel:"noopener noreferrer"},Ye=e("code",null,"RPUSH",-1),qe={href:"https://redis.io/commands/lpop",target:"_blank",rel:"noopener noreferrer"},Ze=e("code",null,"LPOP",-1),we={href:"https://redis.io/commands/rpop",target:"_blank",rel:"noopener noreferrer"},Je=e("code",null,"RPOP",-1),We={href:"https://redis.io/commands/llen",target:"_blank",rel:"noopener noreferrer"},Qe=e("code",null,"LLEN",-1),en={href:"https://redis.io/commands/lmove",target:"_blank",rel:"noopener noreferrer"},nn=e("code",null,"LMOVE",-1),rn={href:"https://redis.io/commands/ltrim",target:"_blank",rel:"noopener noreferrer"},on=e("code",null,"LTRIM",-1),tn={href:"https://redis.io/commands/blpop",target:"_blank",rel:"noopener noreferrer"},sn=e("code",null,"BLPOP",-1),ln={href:"https://redis.io/commands/blmove",target:"_blank",rel:"noopener noreferrer"},dn=e("code",null,"BLMOVE",-1),an=e("h3",{id:"set",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#set","aria-hidden":"true"},"#"),n(" set")],-1),cn=e("p",null,"使用场景：",-1),hn=e("p",null,[n("​ 网站 UV 统计（数据量巨大的场景还是 "),e("code",null,"HyperLogLog"),n("更适合一些）、共同关注（交集）、可能认识的人(差集)")],-1),_n=e("h4",{id:"常见命令-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常见命令-1","aria-hidden":"true"},"#"),n(" 常见命令")],-1),pn={href:"https://redis.io/commands/sadd",target:"_blank",rel:"noopener noreferrer"},un=e("code",null,"SADD",-1),mn={href:"https://redis.io/commands/srem",target:"_blank",rel:"noopener noreferrer"},gn=e("code",null,"SREM",-1),fn={href:"https://redis.io/commands/sismember",target:"_blank",rel:"noopener noreferrer"},bn=e("code",null,"SISMEMBER",-1),vn={href:"https://redis.io/commands/sinter",target:"_blank",rel:"noopener noreferrer"},xn=e("code",null,"SINTER",-1),kn={href:"https://redis.io/commands/scard",target:"_blank",rel:"noopener noreferrer"},Dn=e("code",null,"SCARD",-1),In=e("h3",{id:"hash",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#hash","aria-hidden":"true"},"#"),n(" hash")],-1),Rn=e("p",null,"使用场景：",-1),En=e("p",null,"​ 缓存对象",-1),An=e("h4",{id:"常见命令-2",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常见命令-2","aria-hidden":"true"},"#"),n(" 常见命令")],-1),yn={href:"https://redis.io/commands/hset",target:"_blank",rel:"noopener noreferrer"},Tn=e("code",null,"HSET",-1),zn={href:"https://redis.io/commands/hget",target:"_blank",rel:"noopener noreferrer"},Ln=e("code",null,"HGET",-1),On={href:"https://redis.io/commands/hmget",target:"_blank",rel:"noopener noreferrer"},Xn=e("code",null,"HMGET",-1),Pn={href:"https://redis.io/commands/hincrby",target:"_blank",rel:"noopener noreferrer"},Nn=e("code",null,"HINCRBY",-1),Bn=e("h3",{id:"zset-排序集",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#zset-排序集","aria-hidden":"true"},"#"),n(" zset （排序集）")],-1),Sn=e("p",null,"Redis 排序集是按关联分数排序的唯一字符串（成员）的集合。当多个字符串具有相同分数时，字符串按字典顺序排序。排序集的一些用例包括：",-1),Gn=e("ul",null,[e("li",null,"排行榜。例如，您可以使用排序集轻松维护大型在线游戏中最高分数的有序列表。"),e("li",null,"速率限制器。特别是，您可以使用排序集构建滑动窗口速率限制器，以防止过多的 API 请求。")],-1),Cn=e("h4",{id:"常用命令-5",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常用命令-5","aria-hidden":"true"},"#"),n(" 常用命令")],-1),Mn={href:"https://redis.io/commands/zadd",target:"_blank",rel:"noopener noreferrer"},Un=e("code",null,"ZADD",-1),Hn={href:"https://redis.io/commands/zrange",target:"_blank",rel:"noopener noreferrer"},jn=e("code",null,"ZRANGE",-1),Kn={href:"https://redis.io/commands/zrank",target:"_blank",rel:"noopener noreferrer"},Vn=e("code",null,"ZRANK",-1),Fn={href:"https://redis.io/commands/zrevrank",target:"_blank",rel:"noopener noreferrer"},$n=e("code",null,"ZREVRANK",-1),Yn=e("h2",{id:"todo-底层数据结构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#todo-底层数据结构","aria-hidden":"true"},"#"),n(" todo 底层数据结构")],-1);function qn(Zn,wn){const r=d("ExternalLinkIcon");return i(),l("div",null,[c,e("ul",null,[e("li",null,[e("a",h,[_,o(r)]),n("向流添加一个新条目。")]),e("li",null,[e("a",p,[u,o(r)]),n("读取一个或多个条目，从给定位置开始并及时向前移动。")]),e("li",null,[e("a",m,[g,o(r)]),n("返回两个提供的条目 ID 之间的条目范围。")]),e("li",null,[e("a",f,[b,o(r)]),n("返回流的长度。")])]),e("p",null,[e("a",v,[n("完整命令"),o(r)])]),x,e("ul",null,[e("li",null,[e("a",k,[D,o(r)]),n("用于创建、销毁和管理消费者组。")]),e("li",null,[e("a",I,[R,o(r)]),n("用于通过消费者组从流中读取数据。")]),e("li",null,[e("a",E,[A,o(r)]),n("是允许消费者将待处理消息标记为已正确处理的命令。")])]),y,e("p",null,[n("前两个特殊 ID 是"),T,n("和"),z,n("，用于通过该"),e("a",L,[O,o(r)]),n("命令进行范围查询。这两个 ID 分别表示可能的最小 ID（基本上是"),X,n("）和可能的最大 ID（即"),P,n("）。")]),N,e("p",null,[n("另一个特殊的ID是"),B,n("，它是仅与消费者组相关且仅在使用"),e("a",S,[G,o(r)]),n("该命令时具有特殊含义。这个特殊的 ID 意味着我们只需要迄今为止从未交付给其他消费者的条目。所以基本上该"),C,n("ID是消费者组"),M]),e("p",null,[n("最后，特殊 ID"),U,n("只能与命令一起使用"),e("a",H,[j,o(r)]),n("，意味着为我们自动为新条目选择一个 ID。")]),K,e("ul",null,[e("li",null,[e("a",V,[F,o(r)]),n("将提供的偏移量处的一位设置为 0 或 1。")]),e("li",null,[e("a",$,[Y,o(r)]),n("返回给定偏移处的位值。")]),e("li",null,[e("a",q,[Z,o(r)]),n("在不同字符串之间执行按位运算。提供的运算有 AND、OR、XOR 和 NOT。")]),e("li",null,[e("a",w,[J,o(r)]),n("执行总体计数，报告设置为 1 的位数。")]),e("li",null,[e("a",W,[Q,o(r)]),n("查找具有指定值 0 或 1 的第一位。")])]),e("p",null,[e("a",ee,[ne,o(r)]),n("且"),e("a",re,[oe,o(r)]),n("均为 O(1)。 "),e("a",te,[se,o(r)]),n("是 O(n)，其中"),ie,n("是比较中最长字符串的长度")]),le,de,ae,ce,he,e("ul",null,[e("li",null,[e("a",_e,[pe,o(r)]),n("以原子方式设置、递增和读取一个或多个值。")]),e("li",null,[e("a",ue,[me,o(r)]),n("是 的只读变体"),e("a",ge,[fe,o(r)]),n("。")])]),be,e("ul",null,[e("li",null,[e("a",ve,[xe,o(r)]),n("将位置添加到给定的地理空间索引（请注意，使用此命令时，经度位于纬度之前）。")]),e("li",null,[e("a",ke,[De,o(r)]),n("返回具有给定半径或边界框的位置。")])]),Ie,Re,Ee,Ae,ye,e("ul",null,[e("li",null,[e("a",Te,[ze,o(r)]),n("存储一个字符串值。")]),e("li",null,[e("a",Le,[Oe,o(r)]),n("仅当键尚不存在时才存储字符串值。对于实现锁很有用。")]),e("li",null,[e("a",Xe,[Pe,o(r)]),n("检索字符串值。")]),e("li",null,[e("a",Ne,[Be,o(r)]),n("在单个操作中检索多个字符串值。")]),e("li",null,[e("a",Se,[Ge,o(r)]),n("以原子方式递增（并在传递负数时递减）存储在给定键处的计数器。")]),e("li",null,[n("存在另一个用于浮点计数器的命令："),e("a",Ce,[Me,o(r)]),n("。")])]),Ue,He,je,Ke,e("ul",null,[e("li",null,[e("a",Ve,[Fe,o(r)]),n("将新元素添加到列表的头部；"),e("a",$e,[Ye,o(r)]),n("添加到尾巴。")]),e("li",null,[e("a",qe,[Ze,o(r)]),n("从列表头部删除并返回一个元素；"),e("a",we,[Je,o(r)]),n("做同样的事情，但是从列表的尾部开始。")]),e("li",null,[e("a",We,[Qe,o(r)]),n("返回列表的长度。")]),e("li",null,[e("a",en,[nn,o(r)]),n("以原子方式将元素从一个列表移动到另一个列表。")]),e("li",null,[e("a",rn,[on,o(r)]),n("将列表缩小到指定的元素范围。")]),e("li",null,[e("a",tn,[sn,o(r)]),n("从列表头部删除并返回一个元素。如果列表为空，则该命令将阻塞，直到有元素可用或达到指定的超时为止。")]),e("li",null,[e("a",ln,[dn,o(r)]),n("以原子方式将元素从源列表移动到目标列表。如果源列表为空，该命令将阻塞，直到有新元素可用。")])]),an,cn,hn,_n,e("ul",null,[e("li",null,[e("a",pn,[un,o(r)]),n("将新成员添加到集合中。")]),e("li",null,[e("a",mn,[gn,o(r)]),n("从集合中删除指定的成员。")]),e("li",null,[e("a",fn,[bn,o(r)]),n("测试字符串的集合成员资格。")]),e("li",null,[e("a",vn,[xn,o(r)]),n("返回两个或多个集合共有的成员集（即交集）。")]),e("li",null,[e("a",kn,[Dn,o(r)]),n("返回集合的大小（也称为基数）。")])]),In,Rn,En,An,e("ul",null,[e("li",null,[e("a",yn,[Tn,o(r)]),n("设置哈希上一个或多个字段的值。")]),e("li",null,[e("a",zn,[Ln,o(r)]),n("返回给定字段的值。")]),e("li",null,[e("a",On,[Xn,o(r)]),n("返回一个或多个给定字段的值。")]),e("li",null,[e("a",Pn,[Nn,o(r)]),n("将给定字段的值增加所提供的整数。")])]),Bn,Sn,Gn,Cn,e("ul",null,[e("li",null,[e("a",Mn,[Un,o(r)]),n("将新成员和关联分数添加到排序集中。如果该成员已存在，则更新分数。")]),e("li",null,[e("a",Hn,[jn,o(r)]),n("返回在给定范围内排序的有序集的成员。")]),e("li",null,[e("a",Kn,[Vn,o(r)]),n("返回所提供成员的排名，假设按升序排序。")]),e("li",null,[e("a",Fn,[$n,o(r)]),n("返回所提供成员的排名，假设排序集按降序排列。")])]),Yn])}const Wn=s(a,[["render",qn],["__file","redis-data-types.html.vue"]]);export{Wn as default};
