import{_ as i,V as p,W as l,X as n,Y as e,Z as t,$ as s,F as o}from"./framework-159025ca.js";const c={},r=s('<h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h1><h2 id="数据权限" tabindex="-1"><a class="header-anchor" href="#数据权限" aria-hidden="true">#</a> 数据权限</h2><p>我们不光要控制一个用户能访问<strong>哪些资源</strong>，还需要控制用户只能访问资源中的<strong>某部分数据</strong>。</p><p>控制一个用户能访问哪些资源我们有很成熟的权限管理模型即<strong>RBAC</strong>，但是控制用户只能访问某部分资源（即我们常说的数据权限）使用RBAC模型是不够的。</p><p>在RBAC模型下，系统只会验证用户A是否属于角色RoleX，而不会判断用户A是否能访问只属于用户B的数据DataB。这种问题我们称之为“水平权限管理问题”。</p><p>列表数据权限，主要通过数据权限控制行数据，让不同的人有不同的查看数据规则；要实现数据权限，最重要的是需要抽象出数据规则。</p><h3 id="数据规则" tabindex="-1"><a class="header-anchor" href="#数据规则" aria-hidden="true">#</a> 数据规则</h3><p>比如我们系统的商机数据，需要从下面几个维度来控制数据访问权限。</p><ul><li>普通的销售人员只能看到自己的数据</li><li>地区的销售经理能看到当前地区的所有数据</li><li>销售总监可以看到所有的销售数据</li></ul><p>上面的这些维度就是数据规则。</p><h3 id="实现思路" tabindex="-1"><a class="header-anchor" href="#实现思路" aria-hidden="true">#</a> <strong>实现思路</strong></h3><p>RBAC五张表，用户表、角色表、权限表、用户角色表、角色权限表，实现数据权限，我们可以在角色的基础上，再关联一张也就是在RBAC的基础上，添加了数据权限规则和角色的关联关系。</p><p>1: 定义DataPermission注解，标识在需要数据权限控制的方法或者类上，标识这个方法走数据权限的控制。</p><p>2: 定义aop切面，切点的匹配逻辑就是我们刚才定义的DataPermission注解。</p><p>3: 增强的逻辑也很简单，就是把方法或者类上的DataPermission注解信息入栈（<code>ThreadLocal&lt;LinkedList&gt;&gt;</code>防止方法嵌套调用）。</p><p>4: 收集容器中生效的规则，规则可以认为是我们拼接的sql表达式，可以根据当前表的部门、用户id来定义规则。</p><p>5: 添加mp的拦截器，通过拼接规则重写sql。</p><p>当然，我们可以自定义我们的规则，也就是那张表的那个字段表示部门或者用户，来达到查询全部、查询本部门、查询下级部门、查询仅自己的效果。</p><h3 id="防止数据越权" tabindex="-1"><a class="header-anchor" href="#防止数据越权" aria-hidden="true">#</a> <strong>防止数据越权</strong></h3><p>这里我们先介绍一下可能出现的数据越权行为。</p><ul><li>当前用户包含两个数据权限，其中一个是指向特定菜单的 “仅看自己” 的过滤规则，另一个是面向所有菜单的 “查看全部” 过滤规则。 <img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/26/dcqtqs.png" alt="img" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/26/MRJVUl.png" alt="img" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/26/14KuJf.png" alt="img" loading="lazy"></li><li>从上图两个数据权限的配置可以看出，用户 userA 在访问 “产品管理” 菜单所对应的接口时，数据过滤权限是 “只看自己”，而访问其他菜单指向的接口时，其数据权限是 “查看全部”。</li><li>试想一下，如果前端在请求头中传给后台的 MenuId <strong>不是</strong> “产品管理” 菜单所对应的的MenuId，然而实际访问的接口却是 “产品管理” 菜单所对应的查询接口。</li><li>上一步的查询结果是显而易见的，userA 越权查询到了全部的 “产品列表” 数据。</li></ul><p>如何解决上述数据越权问题的？</p><ul><li>在用户登录时，我们已经查询到了用户菜单列表、操作权限列表、数据权限列表和系统白名单接口列表等数据。</li><li>基于上一步获取的菜单和权限数据列表，我们可以推演出每一个菜单所关联的权限资源 (后台接口URL) 数据列表。并将推演后的关联结果，存入 Redis 缓存。</li><li>在进行权限过滤之前，MybatisDataPermInterceptor 中的统一拦截方法，会先获取当前请求头中的 MenuId 值，然后再到缓存中判断当前请求的 URL 是否与该菜单存在关联关系。这样就能彻底的解决了，因伪造 MenuId 而引发的数据越权访问问题。</li></ul><h2 id="防重放" tabindex="-1"><a class="header-anchor" href="#防重放" aria-hidden="true">#</a> 防重放</h2><p>我们在设计接口的时候，最怕一个接口被用户截取用于重放攻击。重放攻击是什么呢？就是把你的请求原封不动地再发送一次，两次...n次，一般正常的请求都会通过验证进入到正常逻辑中，如果这个正常逻辑是插入数据库操作，那么一旦插入数据库的语句写的不好，就有可能出现多条重复的数据。一旦是比较慢的查询操作，就可能导致数据库堵住等情况。</p><p>这里就有一种防重放的机制来做请求验证。</p><h3 id="timestamp-nonce-时间戳-随机数" tabindex="-1"><a class="header-anchor" href="#timestamp-nonce-时间戳-随机数" aria-hidden="true">#</a> <strong>timestamp+nonce</strong>（时间戳+随机数）</h3><p>我们常用的防止重放的机制是使用timestamp和nonce来做的重放机制。</p><p>timestamp用来表示请求的当前时间戳，这个时间戳当然要和服务器时间戳进行校正过的。我们预期正常请求带的timestamp参数会是不同的（预期是正常的人每秒至多只会做一个操作）。每个请求带的时间戳不能和当前时间超过一定规定的时间。比如60s。这样，这个请求即使被截取了，你也只能在60s内进行重放攻击。过期失效。</p><p>但是这样也是不够的，还有给攻击者60s的时间。所以我们就需要使用一个nonce，随机数。</p><p>nonce是由客户端根据足够随机的情况生成的，比如 md5(timestamp+rand(0, 1000)); 它就有一个要求，正常情况下，在短时间内（比如60s）连续生成两个相同nonce的情况几乎为0。</p><h3 id="服务端" tabindex="-1"><a class="header-anchor" href="#服务端" aria-hidden="true">#</a> <strong>服务端</strong></h3><p>服务端第一次在接收到这个nonce的时候做下面行为： 1： 去redis中查找是否有key为nonce:{nonce}的string 2： 如果没有，则创建这个key，把这个key失效的时间和验证timestamp失效的时间一致，比如是60s。 3： 如果有，说明这个key在60s内已经被使用了，那么这个请求就可以判断为重放请求。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> <strong>示例</strong></h3><p>那么比如，下面这个请求：</p>',35),d={href:"http://a.com/?uid=123&timestamp=1480556543&nonce=43f34f33&sign=80b886d71449cb33355d017893720666",target:"_blank",rel:"noopener noreferrer"},u=s(`<p>这个请求中国的uid是我们真正需要传递的有意义的参数</p><p>timestamp，nonce，sign都是为了签名和防重放使用。</p><p>timestamp是发送接口的时间。</p><p>nonce是随机串。</p><p>sign是对uid，timestamp,nonce的签名。签名的方法可以是md5({秘要}key1=val1&amp;key2=val2&amp;key3=val3...)</p><p>服务端接到这个请求： 1： 先验证sign签名是否合理，<strong>证明请求参数没有被中途篡改</strong>。 2： 再验证timestamp是否过期，证明请求是在最近60s被发出的 3 ：最后验证nonce是否已经有了，证明这个请求不是60s内的重放请求</p><h2 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存" aria-hidden="true">#</a> 多级缓存</h2><p>基于spring cache。</p><p>一级缓存Caffeine、二级缓存redis。</p><p>通过重写CacheManager实现。</p><p>通过redis的发布订阅实现清理本地缓存。</p><h2 id="幂等" tabindex="-1"><a class="header-anchor" href="#幂等" aria-hidden="true">#</a> 幂等</h2><p>幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</p><p>很多重要的情况都需要幂等的特性来支持。比如如下的几种业务场景:</p><ul><li>前端重复提交数据，应该后台只产生对应这个数据的一个响应；</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱；</li><li>发送短信给用户，也应该也只能只发一次；</li><li>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题等等。</li></ul><p>在设计幂等接口时，重点关注新增接口和更新接口。因为查询和删除操作，天生是幂等的（有些删除比较特殊，也不满足幂等性，关于这一点该文章不展开说明），不需要我们提供额外的技术手段来保证幂等性。</p><p>对于新增和更新接口，大致有以下几种方案可以保证接口幂等性。</p><h3 id="_1、唯一索引-防止新增脏数据。" tabindex="-1"><a class="header-anchor" href="#_1、唯一索引-防止新增脏数据。" aria-hidden="true">#</a> <strong>1、唯一索引：防止新增脏数据。</strong></h3><p>比如：每个用户只能有一个资金账户，怎么防止给用户创建了多个账户呢？给资金账户表中的用户 ID 加唯一索引。</p><p>方案要点：唯一索引或唯一组合索引，用来防止新增数据的时候存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在，直接返回查询结果）；</p><h3 id="_2、token机制-防止页面重复提交。" tabindex="-1"><a class="header-anchor" href="#_2、token机制-防止页面重复提交。" aria-hidden="true">#</a> <strong>2、token机制：防止页面重复提交。</strong></h3><p>原理上一般通过 redis 来实现。当客户端请求页面时，服务器会生成一个随机数 Token，将该 Token 放置到 redis 缓存中，然后将Token发给客户端（一般通过构造hidden表单）。 下次客户端提交请求时，Token会随着表单一起提交到服务器端。</p><p>服务器端第一次验证相同之后，会将 redis 中的 Token 值删除，若用户重复提交，第二次验证会失败，因为用户提交的表单中的 Token redis 中 Token 已经删除了。</p><h3 id="_3、悲观锁" tabindex="-1"><a class="header-anchor" href="#_3、悲观锁" aria-hidden="true">#</a> <strong>3、悲观锁</strong></h3><p>获取数据的时候加锁获取。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select * from table_xxx where id=&#39;xxx&#39; for update; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：id 字段一定是主键或者唯一索引。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会比较长，影响服务器的性能；</p><h3 id="_4、乐观锁" tabindex="-1"><a class="header-anchor" href="#_4、乐观锁" aria-hidden="true">#</a> <strong>4、乐观锁</strong></h3><p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p><p>乐观锁可以通过添加 version 来实现。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>update table_xxx set name=#name#,version=version+1 where version=#version#；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5、分布式锁" tabindex="-1"><a class="header-anchor" href="#_5、分布式锁" aria-hidden="true">#</a> <strong>5、分布式锁</strong></h3><p>如果是分布式系统，无法构建全局唯一索引，这时候可以引入分布式锁，通过中间件(redis或zookeeper)构建分布式锁。</p><p>一般的操作都是，<strong>先去获取锁，做操作，之后释放锁</strong>，这其实是把多线程并发的思路，引入多个系统。</p><p>方案要点：锁的标示怎么区分业务场景；一般是通过(用户ID+业务场景等)获取分布式锁</p><p>分布式锁幂等实现思路：</p><p>利用aop+redis的setnx指令，方法执行完成删除掉key即可。</p><h2 id="限流" tabindex="-1"><a class="header-anchor" href="#限流" aria-hidden="true">#</a> 限流</h2><h3 id="计数限流" tabindex="-1"><a class="header-anchor" href="#计数限流" aria-hidden="true">#</a> 计数限流</h3><p>保存一个计数器，处理一个请求加一，处理完后减一，若超过阈值拒绝请求。</p><ul><li><p>优点</p></li><li><ul><li>简单粗暴，单机在 java 可用 Atomic 等原子类、分布式就 Redis incr</li></ul></li><li><p>缺点</p></li><li><ul><li>假设单机设的 1 万阈值，计数器为 0，若在 1 秒内收到 1 万个突发请求，可能超过机器的处理上限而导致机器崩溃。</li></ul></li><li></li><li></li></ul><h3 id="固定窗口限流" tabindex="-1"><a class="header-anchor" href="#固定窗口限流" aria-hidden="true">#</a> 固定窗口限流</h3><p>相比于计数限流主要是多了个时间窗口的概念，计数器每过一个时间窗口就重置，规则为：</p><ul><li><ul><li>请求次数小于阈值，允许访问并且计数器 +1</li><li>请求次数大于阈值，拒绝访问</li><li>这个时间窗口过了之后，计数器清零</li></ul></li><li><p>缺点</p></li><li><ul><li>无法保证限流速率，因而无法保证突然激增的流量，会遇到固定窗口临界问题，即这个算法有时会让通过请求量允许为限制的两倍</li><li>如图，限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求</li></ul></li></ul><h3 id="滑动窗口限流" tabindex="-1"><a class="header-anchor" href="#滑动窗口限流" aria-hidden="true">#</a> 滑动窗口限流</h3><ul><li>将时间划分为多个区间</li><li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间</li><li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间</li><li>如果当前窗口内的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃</li></ul><h3 id="漏桶算法" tabindex="-1"><a class="header-anchor" href="#漏桶算法" aria-hidden="true">#</a> 漏桶算法</h3><ul><li><p>水滴持续漏到桶中，底部定速流出，如果桶空了则停止漏水，如果满了多余的水会被直接抛弃。</p></li><li><p>实现</p></li><li><p>使用队列，服务的请求会存在队列中，服务的提供方按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</p></li><li><p>优点</p></li><li><p>宽进严出，无论请求数量和速率多大，都能按照固定速率流出，流量处理非常平滑</p></li><li><p>缺点</p></li><li><p>当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应</p></li></ul><h3 id="令牌桶算法" tabindex="-1"><a class="header-anchor" href="#令牌桶算法" aria-hidden="true">#</a> 令牌桶算法</h3><ul><li><p>以固定速率生成令牌存入到令牌桶中。</p></li><li><p>如果令牌数量超过桶的限制则直接丢弃。</p></li><li><p>当请求到达是，会先从令牌桶中取令牌，取到了令牌的请求可以执行，如果桶空了，那么取令牌的请求会被直接丢弃。</p></li><li><p>优点</p></li><li><p>能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求</p></li></ul>`,50),k={href:"https://fxzcloud.tech/article/resilience4j/3.resilience4j-ratelimiter.html",target:"_blank",rel:"noopener noreferrer"},v=s(`<h2 id="审计" tabindex="-1"><a class="header-anchor" href="#审计" aria-hidden="true">#</a> 审计</h2><p>aop + spel表达式</p><h2 id="多租户" tabindex="-1"><a class="header-anchor" href="#多租户" aria-hidden="true">#</a> 多租户</h2><p><strong>什么是SaaS系统</strong>？</p><p>SaaS平台是运营saas软件的平台。SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，租户(企业)无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统。SaaS 是一种软件布局模型，其应用专为网络交付而设计，便于用户通过互联网托管、部署及接入。</p><p>简单来说就是租户给SaaS平台付租金就能使用平台提供的功能服务，当下比较典型就是各种云平台、云服务厂商。</p><h3 id="一个租户独立一个数据库" tabindex="-1"><a class="header-anchor" href="#一个租户独立一个数据库" aria-hidden="true">#</a> <strong>一个租户独立一个数据库</strong></h3><p>一个租户独立使用一个数据库，那就意味着我们的SaaS系统需要连接多个数据库，这种实现方案其实就和分库分表架构设计是一样的，好处就是数据隔离级别高、安全性好，毕竟一个租户单用一个数据库，但是物理硬件成本，维护成本也变高了。</p><h3 id="独立的表空间" tabindex="-1"><a class="header-anchor" href="#独立的表空间" aria-hidden="true">#</a> <strong>独立的表空间</strong></h3><p>这种方案的实现方式，就是所有租户共用一个数据库系统，但是每个租户在数据库系统中拥有一个独立的表空间。</p><h3 id="按租户id字段隔离租户" tabindex="-1"><a class="header-anchor" href="#按租户id字段隔离租户" aria-hidden="true">#</a> <strong>按租户id字段隔离租户</strong></h3><p>这种方案是多租户方案中最简单的数据隔离方法，即在每张表中都添加一个用于区分租户的字段（如tenant_id或org_id啥的）来标识每条数据属于哪个租户，当进行查询的时候每条语句都要添加该字段作为过滤条件，其特点是所有租户的数据全都存放在同一个表中，数据的隔离性是最低的，完全是通过字段来区分的，很容易把数据搞串或者误操作。</p><p>用户登录返回tenant_id。</p><p>用户请求投携带tenant_id。</p><p>拦截器获取请求的tenant_id，放到上下文。</p><p>拦截器校验租户的合法性。</p><p>aop解析注解请求，把不需要多租户处理的方法放到上下文。</p><h4 id="缓存层面" tabindex="-1"><a class="header-anchor" href="#缓存层面" aria-hidden="true">#</a> 缓存层面</h4><p>重写RedisCacheManager，以租户id拼接key</p><h4 id="数据库层面" tabindex="-1"><a class="header-anchor" href="#数据库层面" aria-hidden="true">#</a> 数据库层面</h4><p>mp多租户插件，重写sql。</p><h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h2><h4 id="redisson如何加锁并保证加锁的原子性" tabindex="-1"><a class="header-anchor" href="#redisson如何加锁并保证加锁的原子性" aria-hidden="true">#</a> redisson如何加锁并保证加锁的原子性？</h4><p>1: 判断key是否存在</p><p>2: 不存在的话：</p><ul><li>设置hash结构字段自增，表示重入的次数。</li><li>设置key的过期时间。</li></ul><p>3: 存在的话：</p><ul><li>通过hash结构判断是否是当前线程，是否话重入加锁。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过tryLockInnerAsync方法的实现可以看出，最终加锁是通过lua脚本来实现加锁的，redis在执行lua脚本的时候是可以保证加锁的原子性的，所以Redisson实现加锁的原子性是依赖lua脚本来实现的。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/cWHHZc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/RjAqNb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="为什么需要设置加锁key的过期时间" tabindex="-1"><a class="header-anchor" href="#为什么需要设置加锁key的过期时间" aria-hidden="true">#</a> 为什么需要设置加锁key的过期时间</h4><p>为了避免死锁。</p><p>redisson提供了看门狗的逻辑，如果不设置过期时间的话，redisson会把key的过期时间设置为30s，然后定时任务轮训去续期key。</p><p>这会导致一个问题，只要客户端不宕机或者释放key的话，key会一直存在，导致死锁。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/HP1ydR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过上面可以看到，如果不设置过期时间的话，会通过scheduleExpirationRenewal进行续约，也就是看门狗的逻辑。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/RKJQ2V.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/CU2xVH.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="如何实现可重入加锁" tabindex="-1"><a class="header-anchor" href="#如何实现可重入加锁" aria-hidden="true">#</a> 如何实现可重入加锁</h4><p>通过上述hash结构，维护一个计数器即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何主动释放锁和避免其它线程释放了自己加的锁" tabindex="-1"><a class="header-anchor" href="#如何主动释放锁和避免其它线程释放了自己加的锁" aria-hidden="true">#</a> 如何主动释放锁和避免其它线程释放了自己加的锁</h4><p>unLock方法。</p><p>可以看到，他会判断hash结构中，锁是否由当前线程持有，然后判断重入次数，次数为0的时候释放掉锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (counter &gt; 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return 0; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;del&#39;, KEYS[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return 1; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil;&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getChannelName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LockPubSub</span><span class="token punctuation">.</span><span class="token constant">UNLOCK_MESSAGE</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现超时自动释放锁" tabindex="-1"><a class="header-anchor" href="#如何实现超时自动释放锁" aria-hidden="true">#</a> 如何实现超时自动释放锁</h4><p>综上，设置锁的过期时间，redisson就不会采用看门狗的方式续期，key到期自动释放了。</p><h4 id="如何实现不同线程加锁的互斥" tabindex="-1"><a class="header-anchor" href="#如何实现不同线程加锁的互斥" aria-hidden="true">#</a> 如何实现不同线程加锁的互斥</h4><p>lua脚本的原子性保证了多个线程只会加锁成功一次，同时存了线程id信息，保证线程间加锁</p><p>互斥。</p><h4 id="加锁失败之后如何实现阻塞等待加锁" tabindex="-1"><a class="header-anchor" href="#加锁失败之后如何实现阻塞等待加锁" aria-hidden="true">#</a> 加锁失败之后如何实现阻塞等待加锁</h4><p>执行死循环（自旋）的方式来不停地通过tryAcquire方法来尝试加锁，直到加锁成功之后才会跳出死循环，如果一直没有成功加锁，那么就会一直旋转下去，所谓的阻塞，实际上就是自旋加锁的方式。</p><p>但是这种阻塞可能会产生问题，因为如果其它线程释放锁失败，那么这个阻塞加锁的线程会一直阻塞加锁，这肯定会出问题的。所以有没有能够可以指定阻塞的时间，如果超过一定时间还未加锁成功的话，那么就放弃加锁的方法。即推荐使用tryLock。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">boolean</span> interruptibly<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// lock acquired</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RedissonLockEntry</span> entry<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            entry <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getInterrupted</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            entry <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// lock acquired</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// waiting for message</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquireUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token function">unsubscribe</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        get(lockAsync(leaseTime, unit));</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现阻塞等待一定时间还未加锁成功就放弃加" tabindex="-1"><a class="header-anchor" href="#如何实现阻塞等待一定时间还未加锁成功就放弃加" aria-hidden="true">#</a> 如何实现阻塞等待一定时间还未加锁成功就放弃加</h4><p>tryLock方法。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/ka90Hg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="如何实现公平锁" tabindex="-1"><a class="header-anchor" href="#如何实现公平锁" aria-hidden="true">#</a> 如何实现公平锁</h4><p>先到先得。</p><p>线程来加锁的时候，如果加锁失败了，那么会将线程扔到一个集合中，这样就按照加锁的顺序给线程排队，set集合的头部的线程就代表了接下来能够加锁成功的线程。</p><p>当有线程释放了锁之后，其它加锁失败的线程就会来继续加锁，加锁之前会先判断一下set集合的头部的线程跟当前要加锁的线程是不是同一个，如果是的话，那就加锁成功，如果不是的话，那么就加锁失败，这样就实现了加锁的顺序性。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;while true do &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;local firstThreadId2 = redis.call(&#39;lindex&#39;, KEYS[2], 0);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;if firstThreadId2 == false then &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;break;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;local timeout = tonumber(redis.call(&#39;zscore&#39;, KEYS[3], firstThreadId2));&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;if timeout &lt;= tonumber(ARGV[3]) then &quot;</span> <span class="token operator">+</span>
        <span class="token comment">// remove the item from the queue and timeout set</span>
        <span class="token comment">// NOTE we do not alter any other timeout</span>
        <span class="token string">&quot;redis.call(&#39;zrem&#39;, KEYS[3], firstThreadId2);&quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;redis.call(&#39;lpop&#39;, KEYS[2]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;break;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>

<span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;and ((redis.call(&#39;exists&#39;, KEYS[2]) == 0) &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;or (redis.call(&#39;lindex&#39;, KEYS[2], 0) == ARGV[2])) then &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;lpop&#39;, KEYS[2]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;zrem&#39;, KEYS[3], ARGV[2]);&quot;</span> <span class="token operator">+</span>

    <span class="token comment">// decrease timeouts for all waiting in the queue</span>
    <span class="token string">&quot;local keys = redis.call(&#39;zrange&#39;, KEYS[3], 0, -1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;for i = 1, #keys, 1 do &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;redis.call(&#39;zincrby&#39;, KEYS[3], -tonumber(ARGV[4]), keys[i]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>

    <span class="token string">&quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return 1;&quot;</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现读写锁" tabindex="-1"><a class="header-anchor" href="#如何实现读写锁" aria-hidden="true">#</a> 如何实现读写锁</h4><p>Redisson通过RedissonReadWriteLock类来实现读写锁的功能，通过这个类可以获取到读锁或者写锁，所以真正的加锁的逻辑是由读锁和写锁实现的。</p><p>在读写锁的实现中，会往hash数据结构中多维护一个mode的字段，来表示当前加锁的模式。</p><p>所以能够实现读写锁，最主要是因为维护了一个加锁模式的字段mode，这样有线程来加锁的时候，就能根据当前加锁的模式结合读写的特性来判断要不要让当前来加锁的线程加锁成功。</p><p>如果没有加锁，那么不论是读锁还是写锁都能加成功，成功之后根据锁的类型维护mode字段。 如果模式是读锁，那么加锁线程是来加读锁的，就让它加锁成功。 如果模式是读锁，那么加锁线程是来加写锁的，就让它加锁失败。 如果模式是写锁，那么加锁线程是来加写锁的，就让它加锁失败（加锁线程自己除外）。 如果模式是写锁，那么加锁线程是来加读锁的，就让它加锁失败（加锁线程自己除外）。</p><h4 id="如何实现批量加锁-联锁" tabindex="-1"><a class="header-anchor" href="#如何实现批量加锁-联锁" aria-hidden="true">#</a> 如何实现批量加锁(联锁)</h4><p>批量加锁的意思就是同时加几个锁，只有这些锁都算加成功了，才是真正的加锁成功。</p><p>redisson遍历这些锁进行加锁。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/joBrSg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="红锁为了解决什么问题" tabindex="-1"><a class="header-anchor" href="#红锁为了解决什么问题" aria-hidden="true">#</a> 红锁为了解决什么问题</h4><p>集群情况下，那就是客户端对原先的主节点加锁，成功之后还没有来得及同步给从节点，主节点宕机了，从节点变成了主节点，此时从节点是没有加锁信息的，如果有其它的客户端来加锁，是能够加锁成功的。</p><p>红锁算法的基本思想如下：</p><ol><li>获取当前时间戳、唯一标识符和锁的过期时间。</li><li>尝试在多个独立的Redis实例（节点）上获取锁，每个实例对应一个资源。</li><li>如果在<strong>大多数实例</strong>上成功获取到锁，并且总共花费的时间<strong>没有超过锁的过期时间</strong>，则认为获取锁成功。</li><li>如果获取锁成功，执行相关业务逻辑；否则，释放已获取的锁。</li></ol><h2 id="数据脱敏" tabindex="-1"><a class="header-anchor" href="#数据脱敏" aria-hidden="true">#</a> 数据脱敏</h2><p>基于jsckson的序列化器实现。</p><h2 id="数据加解密" tabindex="-1"><a class="header-anchor" href="#数据加解密" aria-hidden="true">#</a> 数据加解密</h2><p>mybatis拦截器 + aes对称加密</p><h3 id="对称加密、非对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密、非对称加密" aria-hidden="true">#</a> 对称加密、非对称加密</h3><p>非对称加密和对称加密在加密和解密过程、加密解密速度、传输的安全性上都有所不同，具体介绍如下：</p><h4 id="加密和解密过程不同" tabindex="-1"><a class="header-anchor" href="#加密和解密过程不同" aria-hidden="true">#</a> 加密和解密过程不同</h4><p>对称加密过程和解密过程使用的<strong>同一个密钥</strong>，加密过程相当于用原文+密钥传输出密文，同时解密过程用密文-密钥可以推导出原文。</p><p>非对称加密采用了<strong>两个密钥</strong>，一般使用<strong>公钥进行加密</strong>，使用<strong>私钥进行解密</strong>。</p><h4 id="加密解密速度不同" tabindex="-1"><a class="header-anchor" href="#加密解密速度不同" aria-hidden="true">#</a> 加密解密速度不同</h4><p>对称加密解密的速度比较快，适合数据比较长时的使用。</p><p>非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/27/nyivw0.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="传输的安全性不同" tabindex="-1"><a class="header-anchor" href="#传输的安全性不同" aria-hidden="true">#</a> 传输的安全性不同</h4><p>对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。</p><p>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。</p><h4 id="加密算法不同" tabindex="-1"><a class="header-anchor" href="#加密算法不同" aria-hidden="true">#</a> 加密算法不同</h4><p>在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><p>在对称加密中使用的主要算法有：DES（Data Encryption Standard）、3DES（Triple DES）、AES（Advanced Encryption Standard）、Blowfish等。</p><h4 id="加密安全性不同" tabindex="-1"><a class="header-anchor" href="#加密安全性不同" aria-hidden="true">#</a> 加密安全性不同</h4><p>对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。</p><p>而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。非对称加密与，其安全性更好。</p><h4 id="流程不同" tabindex="-1"><a class="header-anchor" href="#流程不同" aria-hidden="true">#</a> 流程不同</h4><p>非对称加密流程图：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/27/gtZkCG.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>对称加密流程图：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/27/0RK7YG.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="加密耗时不同" tabindex="-1"><a class="header-anchor" href="#加密耗时不同" aria-hidden="true">#</a> 加密耗时不同</h4><p>非对称加密使用一对秘钥，一个用来加密，一个用来解密，这样加密和解密花费时间就会更长长。</p><p>对称加密中加密方和解密方使用同一个密钥，加密解密的速度比较快，耗时短，适合数据比较长时的使用。</p><h4 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> Https</h4><p>https采用对称+非对称</p><p>在 HTTPS 中，通常的流程是这样的：</p><ol><li><strong>建立连接</strong>：客户端向服务器发起连接请求，服务器返回自己的证书（包含公钥）。</li><li><strong>握手阶段</strong>：客户端验证服务器的证书，然后生成一个随机的对称密钥（称为会话密钥）。接着使用服务器的公钥对会话密钥进行加密，然后将加密后的会话密钥发送给服务器。</li><li><strong>密钥交换</strong>：服务器使用自己的私钥解密客户端传递过来的会话密钥，然后双方都拥有相同的会话密钥用于后续通信。</li><li><strong>加密通信</strong>：双方使用这个共享的会话密钥进行对称加密通信，保证通信内容的保密性和完整性。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/27/FBBbU5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="oauth2" tabindex="-1"><a class="header-anchor" href="#oauth2" aria-hidden="true">#</a> OAuth2</h2><p>OAuth 2.0 是一种<strong>授权协议</strong>。</p><p>在 OAuth 2.0 协议中，客户端在请求受保护的资源时，会通过一个 access token（一个代表特定的作用域、生命周期以及其他访问属性的字符串）来作为凭证，access token 由授权服务器在资源所有者认可的情况下颁发给第三方客户端。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/27/A5hluo.png" alt="OAuth2" tabindex="0" loading="lazy"><figcaption>OAuth2</figcaption></figure><h3 id="角色" tabindex="-1"><a class="header-anchor" href="#角色" aria-hidden="true">#</a> 角色</h3><p>OAuth 中定义了 4 种角色：</p><ul><li><strong>资源所有者</strong> <code>resource owner</code>：</li></ul><p>能够授予对受保护资源的访问权的实体。 当资源所有者是人时，它被称为 end-user。</p><ul><li><p><strong>资源服务器</strong> <code>reosource server</code>：</p><p>存放受保护资源的服务器，能够通过 access token 来请求和响应这些受保护的资源。</p></li><li><p><strong>客户端</strong> <code>client</code>：</p><p>请求受保护资源的的一方就可以被看作一个客户端。（这个客户端只是一个概念，具体实现可以是服务器，应用程序，或者 Html 网页 等等，一个资源服务器在请求另一个资源服务器的受保护资源时，其也被视为一个客户端）</p></li><li><p><strong>授权服务器</strong> <code>authorization server</code>：</p><p>当客户端成功通过认证后，向其颁发 token 的服务器</p></li></ul><h3 id="流程" tabindex="-1"><a class="header-anchor" href="#流程" aria-hidden="true">#</a> 流程</h3><p>整体的协议流程大致可以抽象为下图所示，实际的执行流程，根据不同的授权方式，会各有不同。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&gt;| Authorization |
     | Client |                               |     Server    |
     |        |&lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&gt;|    Resource   |
     |        |                               |     Server    |
     |        |&lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>(A) 客户端向资源所有者请求授权。 授权请求可以直接向资源所有者发出(例如密码模式，资源所有者会直接将自己的用户名密码授予给客户端)，但是推荐客户端经由授权服务器作为中转向资源所有者发出(例如授权码模式)</li><li>(B) 客户端收到授权许可，这是一个代表资源所有者的授权的凭据，使用本规范中定义的四种许可类型之一或者使用扩展许可类型表示。授权许可类型取决于客户端请求授权所使用的方法以及授权服务器支持的类型。</li><li>(C) 客户端与授权服务器进行身份认证并出示授权许可来请求 access token 。</li><li>(D) 授权服务器验证客户端以及授权许可，如果授权许可有效，则发出 access token 。</li><li>(E) 客户端向资源服务器请求受保护的资源，并携带 access token 以进行身份验证。</li><li>(F) 资源服务器验证 access token ，如果有效，则返回其请求的受保护资源。</li></ul><h3 id="授权许可" tabindex="-1"><a class="header-anchor" href="#授权许可" aria-hidden="true">#</a> 授权许可</h3><p>授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。</p><p>OAuth 定义了四种许可类型——授权码、隐式许可、资源所有者密码凭据和客户端凭据——以及用于定义其他类型的可扩展性机制。</p><h3 id="授权码-authorization-code" tabindex="-1"><a class="header-anchor" href="#授权码-authorization-code" aria-hidden="true">#</a> 授权码 Authorization Code</h3><p>grant_type：code</p><p>授权码许可类型中，客户端不会直接向资源所有者申请授权，而是通过授权服务中介处理的。整个流程基于重定向，要求客户端必须能够与资源所有者的用户代理（通常是 web 浏览器）进行交互并能够接收来自授权服务器的传入请求（通过重定向）。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---&lt;|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |&gt;---(D)-- Authorization Code ---------&#39;      |
     |  Client |          &amp; Redirection URI                  |
     |         |                                             |
     |         |&lt;---(E)----- Access Token -------------------&#39;
     +---------+       (w/ Optional Refresh Token)
     
     						授权码流程图
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：说明步骤（A）、（B）和（C）的直线因为通过用户代理而被分为两部分。</p><ul><li>（A）客户端通过将资源所有者的用户代理定向到授权端点来启动流程。 客户端包括其客户端标识符、请求的范围、本地状态和重定向URI，授权服务器将在授予(或拒绝)访问后将用户代理发送回该重定向URI。</li><li>（B）授权服务器(通过用户代理)对资源所有者进行身份验证，并确定资源所有者是授予还是拒绝客户端的访问请求。</li><li>（C）假设资源所有者授予访问权，授权服务器使用先前提供的重定向URI(在请求中或在客户端注册期间提供)将用户代理重定向回客户端。 重定向URI的参数中包括一个授权代码和前面客户机提供的任何本地状态。</li><li>（D）客户端通过包含上一步中收到的授权码从授权服务器的令牌端点请求 access token。当发起请求时，客户端与授权服务器进行身份验证。客户端包含用于获得授权码的重定向URI来用于验证。</li><li>（E）授权服务器对客户端进行身份验证，验证授权代码，并确保接收的重定向URI与在步骤（C）中用于重定向（资源所有者的用户代理）到客户端的URI相匹配。如果通过，授权服务器响应返回 access token 与可选的 refresh token</li></ul><h3 id="隐式授权-implicit" tabindex="-1"><a class="header-anchor" href="#隐式授权-implicit" aria-hidden="true">#</a> 隐式授权 Implicit</h3><p>grant_type：implicit</p><p>隐式授权是为用如 JavaScript 等脚本语言在浏览器种实现的客户端而优化的一种简化的授权码流程。在隐式授权流程种，不再给客户端办法授权码，而是直接给客户端颁发一个 access token。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- &amp; Redirection URI ---&gt;|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
     |          |                                |               |
     |          |&lt;---(C)--- Redirection URI ----&lt;|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |&lt;---(E)------- Script ---------&lt;|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>(A) 客户端通过将资源所有者的用户代理定向到授权端点来启动流程。 客户端包括其客户端标识符、请求的范围、本地状态和重定向URI，授权服务器将在授予(或拒绝)访问后将用户代理发送回该重定向URI。</li><li>(B) 授权服务器(通过用户代理)对资源所有者进行身份验证，并确定资源所有者是授予还是拒绝客户端的访问请求。</li><li>(C) 假设资源所有者授予访问权，授权服务器使用先前提供的重定向URI(在请求中或在客户端注册期间提供)将用户代理重定向回客户端。 <strong>重定向URI 的 Hash</strong> 中将包含 access token。</li><li>(D) 用户代理遵循重定向指令，向 web-hosted 的客户端资源发出请求（根据 [RFC2616]，URI 中的 Hash 部分不会携带在请求 URI 中携带）。用户代理将 Hash 中的参数取出并保存。</li><li>(E) web-hosted 的客户端资源返回一个web页面(通常是一个带有嵌入式脚本的HTML文档)，该页面能够访问完整的重定向URI，包括用户代理保留的片段，并提取片段中包含的访问令牌(和其他参数)。</li><li>(F) 用户代理在本地执行由 web-hosted 的客户端资源提供的脚本，从而提取访问令牌。</li><li>(G) 用户代理将访问令牌传递给客户端。</li></ul><blockquote><p>(D) (E) 为非必选步骤，主要用于当用户代理不支持在 response header 的 Location 属性中包含 Hash 片段时，通过返回一个内嵌 javascript 的 html 页面，页面内引导用户点击按钮跳转向 redirect_url</p></blockquote><h3 id="资源所有者密码凭证-resource-owner-password-credentials" tabindex="-1"><a class="header-anchor" href="#资源所有者密码凭证-resource-owner-password-credentials" aria-hidden="true">#</a> 资源所有者密码凭证 Resource Owner Password Credentials</h3><p>grant_type：password</p><p>资源所有者密码凭据许可类型适合于资源所有者与客户端具有信任关系的情况，如设备操作系统或高级特权应用。当启用这种许可类型时授权服务器应该特别关照且只有当其他流程都不可用时才可以。</p><p>这种许可类型适合于能够获得资源所有者凭据（用户名和密码，通常使用交互的形式）的客户端。通过转换已存储的凭据至访问令牌，它也用于迁移现存的使用如HTTP基本或摘要身份验证的直接身份验证方案的客户端至OAuth。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |&gt;--(B)---- Resource Owner -------&gt;|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |&lt;--(C)---- Access Token ---------&lt;|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>(A) 资源所有者提供给客户端它的用户名和密码。</li><li>(B) 通过包含从资源所有者处接收到的凭据，客户端从授权服务器的令牌端点请求访问令牌。当发起请求时，客户端与授权服务器进行身份验证。</li><li>(C) 授权服务器对客户端进行身份验证，验证资源所有者的凭证，如果有效，颁发访问令牌。</li></ul><h3 id="客户端凭证-client-credentials" tabindex="-1"><a class="header-anchor" href="#客户端凭证-client-credentials" aria-hidden="true">#</a> 客户端凭证 Client Credentials</h3><p>grant_type: client_credentials</p><p>当客户端请求访问它所控制的，或者事先与授权服务器协商（所采用的方法超出了本规范的范围）的其他资源所有者的受保护资源，客户端可以只使用它的客户端凭据（或者其他受支持的身份验证方法）请求访问令牌。</p><p>客户端凭据许可类型必须只能由机密客户端使用。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +---------+                                  +---------------+
     |         |                                  |               |
     |         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
     | Client  |                                  |     Server    |
     |         |&lt;--(B)---- Access Token ---------&lt;|               |
     |         |                                  |               |
     +---------+                                  +---------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>（A）客户端与授权服务器进行身份验证并向令牌端点请求访问令牌。</li><li>（B）授权服务器对客户端进行身份验证，如果有效，颁发访问令牌。</li></ul><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h2><p>redis streams实现消费组消费消息。只消费一次</p><p>redis发布订阅实现广播消息。多次消费</p>`,155);function h(m,g){const a=o("ExternalLinkIcon");return p(),l("div",null,[r,n("p",null,[n("a",d,[e("http://a.com?uid=123&timestamp=1480556543&nonce=43f34f33&sign=80b886d71449cb33355d017893720666"),t(a)])]),u,n("p",null,[n("a",k,[e("resilience4j限流"),t(a)])]),v])}const f=i(c,[["render",h],["__file","other.html.vue"]]);export{f as default};
