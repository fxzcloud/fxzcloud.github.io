import{_ as i,V as n,W as e,$ as a}from"./framework-159025ca.js";const r={},t=a(`<h1 id="nginx" tabindex="-1"><a class="header-anchor" href="#nginx" aria-hidden="true">#</a> Nginx</h1><h3 id="_1-什么是nginx" tabindex="-1"><a class="header-anchor" href="#_1-什么是nginx" aria-hidden="true">#</a> 1.什么是Nginx？</h3><p>Nginx是一个 轻量级/高性能的反向代理Web服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发。</p><h3 id="_2-nginx-有哪些优点" tabindex="-1"><a class="header-anchor" href="#_2-nginx-有哪些优点" aria-hidden="true">#</a> 2.<strong>Nginx 有哪些优点？</strong></h3><ul><li>跨平台、配置简单。</li><li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。</li><li>内存消耗小：开启 10 个 Nginx 才占 150M 内存。</li><li>成本低廉，且开源。</li><li>稳定性高，宕机的概率非常小。</li><li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上</li></ul><h3 id="_3-nginx应用场景" tabindex="-1"><a class="header-anchor" href="#_3-nginx应用场景" aria-hidden="true">#</a> 3.<strong>Nginx应用场景？</strong></h3><ul><li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li><li>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</li><li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</li><li>nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。</li></ul><h3 id="_4-nginx怎么处理请求的" tabindex="-1"><a class="header-anchor" href="#_4-nginx怎么处理请求的" aria-hidden="true">#</a> 4.<strong>Nginx怎么处理请求的？</strong></h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server {         # 第一个Server区块开始，表示一个独立的虚拟主机站点
   listen       80； # 提供服务的端口，默认80
   server_name  localhost; # 提供服务的域名主机名
   location / { # 第一个location区块开始
     root   html; # 站点的根目录，相当于Nginx的安装目录
     index  index.html index.html;  # 默认的首页文件，多个用空格分开
} # 第一个location区块结果
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 Socket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</li><li>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</li><li>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</li><li>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</li><li>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</li></ul><h3 id="_5-什么是正向代理" tabindex="-1"><a class="header-anchor" href="#_5-什么是正向代理" aria-hidden="true">#</a> 5.<strong>什么是正向代理？</strong></h3><p>一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p>客户端才能使用正向代理。正向代理总结就一句话：代理端代理的是客户端。例如说：我们使用的OpenVPN 等等。</p><h3 id="_6-什么是反向代理" tabindex="-1"><a class="header-anchor" href="#_6-什么是反向代理" aria-hidden="true">#</a> 6.<strong>什么是反向代理？</strong></h3><p>反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><blockquote><p>反向代理总结就一句话：代理端代理的是服务端。</p></blockquote><h3 id="_7-反向代理服务器的优点是什么" tabindex="-1"><a class="header-anchor" href="#_7-反向代理服务器的优点是什么" aria-hidden="true">#</a> 7.<strong>反向代理服务器的优点是什么?</strong></h3><p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。</p><h3 id="_8-nginx负载均衡的算法怎么实现的-策略有哪些" tabindex="-1"><a class="header-anchor" href="#_8-nginx负载均衡的算法怎么实现的-策略有哪些" aria-hidden="true">#</a> 8.<strong>Nginx负载均衡的算法怎么实现的?策略有哪些?</strong></h3><p>为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</p><p>Nginx负载均衡实现的策略有以下五种：</p><p><strong>1 .轮询(默认)</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p><figure><img src="https://minio.pigx.top/oss/2022/08/YchGWN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li><strong>权重 weight</strong></li></ol><p>weight的值越大，分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</p><figure><img src="https://minio.pigx.top/oss/2022/08/Vi0Lxq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3. ip_hash( IP绑定)</strong></p><p>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题</p><figure><img src="https://minio.pigx.top/oss/2022/08/XTv3Cb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>4. fair(第三方插件)</strong></p><p>必须安装upstream_fair模块。</p><p>对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p><figure><img src="https://minio.pigx.top/oss/2022/08/AtEGtN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.url_hash(第三方插件)</strong></p><p>必须安装Nginx的hash软件包</p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/zvYS6H.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_9-限流怎么做的" tabindex="-1"><a class="header-anchor" href="#_9-限流怎么做的" aria-hidden="true">#</a> 9.<strong>限流怎么做的？</strong></h3><p>Nginx限流就是限制用户请求速度，防止服务器受不了</p><p>限流有3种</p><ul><li>正常限制访问频率（正常流量）</li><li>突发限制访问频率（突发流量）</li><li>限制并发连接数</li></ul><p>Nginx的限流都是基于漏桶流算法</p><blockquote><p>实现三种限流算法</p></blockquote><p>1、正常限制访问频率（正常流量）：</p><p>限制一个用户发送的请求，我Nginx多久接收一个请求。</p><p>Nginx中使用<code>ngx_http_limit_req_module</code>模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用<code>limit_req_zone</code>命令及<code>limit_req</code>命令限制单个IP的请求处理频率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/NfCDfo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。</p><p>2、突发限制访问频率（突发流量）：</p><p>限制一个用户发送的请求，我Nginx多久接收一个。</p><p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？</p><p>Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数：</p><figure><img src="https://minio.pigx.top/oss/2022/08/wLaPqP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求</p><p>3、 限制并发连接数</p><p>Nginx中的<code>ngx_http_limit_conn_module</code>模块提供了限制并发连接数的功能，可以使用<code>limit_conn_zone</code>指令以及<code>limit_conn</code>执行进行配置。接下来我们可以通过一个简单的例子来看下</p><figure><img src="https://minio.pigx.top/oss/2022/08/qLHlsf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。</p><h3 id="_10-生产中如何设置worker进程的数量呢" tabindex="-1"><a class="header-anchor" href="#_10-生产中如何设置worker进程的数量呢" aria-hidden="true">#</a> 10.<strong>生产中如何设置worker进程的数量呢？</strong></h3><p>在有多个cpu的情况下，可以设置多个worker，worker进程的数量可以设置到和cpu的核心数一样多，如果在单个cpu上起多个worker进程，那么操作系统会在多个worker之间进行调度，这种情况会降低系统性能，如果只有一个cpu，那么只启动一个worker进程就可以了。</p><h3 id="_11-nginx-如何开启压缩" tabindex="-1"><a class="header-anchor" href="#_11-nginx-如何开启压缩" aria-hidden="true">#</a> 11.<strong>Nginx 如何开启压缩？</strong></h3><p>开启nginx gzip压缩后，网页、css、js等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。虽然会消耗cpu资源，但是为了给用户更好的体验是值得的。</p><p>开启的配置如下：</p><p>将以上配置放到nginx.conf的<code>http{ … }</code>节点中。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>http {
  # 开启gzip
  gzip on;
 
  # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩
  gzip_min_length 1k;
 
  # gzip 压缩级别 1-10 
  gzip_comp_level 2;
 
  # 进行压缩的文件类型。
 
  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
 
  # 是否在http header中添加Vary: Accept-Encoding，建议开启
  gzip_vary on;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存并重启nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。</p><h3 id="_12-请解释nginx服务器上的master和worker进程分别是什么" tabindex="-1"><a class="header-anchor" href="#_12-请解释nginx服务器上的master和worker进程分别是什么" aria-hidden="true">#</a> 12.请解释Nginx服务器上的Master和Worker进程分别是什么?</h3><p>主程序 Master process 启动后，通过一个 for 循环来 接收 和 处理外部信号 ； 主进程通过 fork() 函数产生 worker 子进程 ，每个子进程执行一个 for循环来实现Nginx服务器 对事件的接收和处理 。</p>`,69),s=[t];function l(o,p){return n(),e("div",null,s)}const d=i(r,[["render",l],["__file","13-nginx.html.vue"]]);export{d as default};
