import{_ as t,V as o,W as a,$ as e}from"./framework-159025ca.js";const n={},p=e(`<h1 id="seata" tabindex="-1"><a class="header-anchor" href="#seata" aria-hidden="true">#</a> Seata</h1><h3 id="_1-seata-at模式原理流程" tabindex="-1"><a class="header-anchor" href="#_1-seata-at模式原理流程" aria-hidden="true">#</a> 1.Seata AT模式原理流程</h3><pre><code>	Seata 是一款阿里开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案，github地址：https://github.com/seata/seata。
</code></pre><p><strong>RM</strong>：资源管理者（Resource Manager ），对应微服务架构中小型服务的业务数据库，业务数据库代表了一个分支事务。RM管理分支事务并与 TC 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</p><p><strong>TC</strong>：事务协调者（Transaction Coordinator），负责管理整个分布式事务，每个节点的分支事务在执行之前，都会在事务协调者上注册，本地事务执行结束后，还会向协调者汇报。当事务需要提交或回滚时，也协调者负责推送给各个RM。每个节点的分支事务在执行之前，使用XID向TC注册分支事务并接收TC的提交或回滚指令。</p><p><strong>TM</strong>：事务管理者（Transaction Manager）,分布式事务的发起者，负责向TC申请全局事务XID。TM在调用其他服务提供的API执行本地分支事务时会向各分支事务传递XID。</p><figure><img src="https://minio.pigx.top/oss/2022/08/pQictL.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>关于分布式事务模式，seata可分为如下几种：</p><p><strong>AT</strong>：Auto Transaction，基于支持本地ACID事务的关系型数据库，对业务无侵入；</p><p><strong>MT</strong>：Manual Transaction，不依赖于底层数据资源的事务支持，需自定义prepare/commit/rollback操作，对业务有侵入；</p><p><strong>XA</strong>：基于数据库的XA实现，目前最新版seata已实现该模式。</p><p><strong>TCC</strong>：TCC模式，对业务有侵入。</p><p>由于目前seata场景中使用AT模式较多，因此本文主要分析AT模式流程。</p><p>AT模式的前提是基于支持本地 ACID 事务的关系型数据库和Java应用基于JDBC访问数据库。<strong>AT模式是二阶段提交协议的演变</strong>：</p><p><strong>一阶段</strong>：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p><p><strong>二阶段</strong>：commit异步化快速完成；rollback通过一阶段的回滚日志进行反向补偿。</p><p><strong>读写隔离</strong> 写隔离保证是通过<strong>全局锁</strong>来保证的，一阶段事务提交前<strong>必须要拿到全局锁</strong>，否则不能提交本地事务，<strong>获取全局锁过程中不能无限等待，超时后放弃，并回滚本地事务，释放本地锁（避免产生死锁）。</strong></p><pre><code>	比如两个全局事务tx1和tx2，分别对a表的m字段做更新操作，m初始值1000。

	tx1先开始，开启本地事务拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的全局锁 ，本地提交释放本地锁。

	tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的全局锁 ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待全局锁 。

	此时会有以下两种情况：

	1. tx1 二阶段全局提交，释放全局锁 。tx2 拿到 全局锁 提交本地事务。
	1. 如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 全局锁 等锁超时，放弃 全局锁 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功（回滚时获取本地锁是没有超时机制的）。因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生脏写的问题。
</code></pre><p><strong>隔离级别</strong> 在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交</strong>（Read Uncommitted），因为分支事务在阶段一就已经提交了，如果其他分支事务还未提交，那么从已提交事务的数据库读取数据能看到更新后的数据，因为此时全局事务还未全部提交，所以是未提交读。</p><p>如果应用在特定场景下，必须要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理：</p><figure><img src="https://minio.pigx.top/oss/2022/08/0BM7df.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回。出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。 <strong>工作机制</strong> 一阶段：</p><ol><li><p>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = &#39;TXC&#39;）等相关的信息。</p></li><li><p>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</p></li><li><p>执行业务 SQL：执行业务更新SQL。</p></li><li><p>查询后镜像：根据前镜像的结果，通过 主键 定位数据。</p></li><li><p>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。</p></li><li><p>提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</p></li><li><p>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</p></li><li><p>将本地事务提交的结果上报给 TC。</p></li></ol><p>一阶段在分支事务提交前向TC注册分支，进行一次通信。</p><p>二阶段-回滚：</p><ol><li><p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p></li><li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p></li><li><p>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</p></li><li><p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句。</p></li><li><p>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p></li></ol><p>二阶段-提交：</p><ol><li><p>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</p></li><li><p>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</p></li></ol><p>UNDO_LOG Table，MySQL示例如下：</p><p>DROP TABLE IF EXISTS <code>undo_log</code>; -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log CREATE TABLE <code>undo_log</code> ( <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT, <code>branch_id</code> bigint(20) NOT NULL, <code>xid</code> varchar(100) NOT NULL, <code>context</code> varchar(128) NOT NULL, <code>rollback_info</code> longblob NOT NULL, <code>log_status</code> int(11) NOT NULL, <code>log_created</code> datetime NOT NULL, <code>log_modified</code> datetime NOT NULL, PRIMARY KEY (<code>id</code>), UNIQUE KEY <code>ux_undo_log</code> (<code>xid</code>,<code>branch_id</code>) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; <strong>关于seata事务的思考</strong> 一般的事务操作有插入、更新、删除几种，下面分别看下个各情况的执行流程：</p><p>插入操作：查询前镜像为空，查询后镜像非空，回滚时直接删除新插入数据即可。</p><p>更新操作：查询前后镜像都非空，回滚直接恢复到查询前镜像即可；</p><p>删除操作：查询前镜像非空，查询后镜像为空，回滚时直接插入原来数据即可，因为二阶段未执行完成时全局锁未释放，所以该过程中其他业务不会插入具有相同id的记录。</p><p>注意：回滚数据时，会对比当前数据和undolog是否一致，如果不一致表示有其他事务进行了数据更新操作，此时时不能直接进行回滚数据的。</p>`,34),i=[p];function r(c,s){return o(),a("div",null,i)}const l=t(n,[["render",r],["__file","09-seata.html.vue"]]);export{l as default};
