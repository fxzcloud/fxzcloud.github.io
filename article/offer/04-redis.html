<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?87d678935e4b33455c0390543e7a759d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><title>redis | 冤种说java</title><meta name="description" content="「流水不争先 争的是滔滔不绝」">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-cde8b1ec.css" as="style"><link rel="stylesheet" href="/assets/style-cde8b1ec.css">
    <link rel="modulepreload" href="/assets/app-f9138082.js"><link rel="modulepreload" href="/assets/framework-159025ca.js"><link rel="modulepreload" href="/assets/04-redis.html-7695bf3e.js"><link rel="modulepreload" href="/assets/04-redis.html-4a5f3902.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="冤种说java"><!----><span class="site-name hide-in-pad">冤种说java</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/source-code/nacos/clusterSync.html" class="nav-link" aria-label="笔记"><span class="font-icon icon iconfont icon-activity" style=""></span>笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/" class="nav-link active" aria-label="博客"><span class="font-icon icon iconfont icon-blog" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/offer/" class="nav-link active" aria-label="八股"><span class="font-icon icon iconfont icon-shell" style=""></span>八股<!----></a></div><div class="nav-item hide-in-mobile"><a href="/me/other.html" class="nav-link" aria-label="其他"><span class="font-icon icon iconfont icon-share" style=""></span>其他<!----></a></div><div class="nav-item hide-in-mobile"><a href="/about.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-alias" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-software" style=""></span><span class="title">nacos</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/nacos/clusterSync.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos集群同步"><!---->nacos集群同步<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/config.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos配置中心"><!---->nacos配置中心<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/discoverAndSubscribe.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务发现和订阅机制"><!---->nacos服务发现和订阅机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/healthCheck.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos健康检查机制"><!---->nacos健康检查机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/register.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务注册"><!---->nacos服务注册<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-alias" style=""></span><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/spring/LookUp%E3%80%81DependsOn%E3%80%81Lazy.html" class="nav-link sidebar-link sidebar-page" aria-label="spring常见注解"><!---->spring常见注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpingInject.html" class="nav-link sidebar-link sidebar-page" aria-label="spring依赖注入"><!---->spring依赖注入<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Cache.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cache注解驱动"><!---->spring cache注解驱动<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Event.html" class="nav-link sidebar-link sidebar-page" aria-label="spring event"><!---->spring event<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20MVC.html" class="nav-link sidebar-link sidebar-page" aria-label="spring mvc源码分析"><!---->spring mvc源码分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring@Async.html" class="nav-link sidebar-link sidebar-page" aria-label="spring异步@Async"><!---->spring异步@Async<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringAop.html" class="nav-link sidebar-link sidebar-page" aria-label="spring aop"><!---->spring aop<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringBeanLIfeCycle.html" class="nav-link sidebar-link sidebar-page" aria-label="spring bean的生命周期"><!---->spring bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringConfig.html" class="nav-link sidebar-link sidebar-page" aria-label="spring配置文件"><!---->spring配置文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringTransaction.html" class="nav-link sidebar-link sidebar-page" aria-label="spring事务"><!---->spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-template" style=""></span><span class="title">spring boot</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringBoot/config.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot配置加载"><!---->spring boot配置加载<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringBoot/start.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot启动流程"><!---->spring boot启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-module" style=""></span><span class="title">spring cloud</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringCloudCommon/configRefresh.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 配置动态刷新"><!---->spring cloud 配置动态刷新<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/loadBalancing.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud loadBalanced"><!---->spring cloud loadBalanced<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/registerAndDiscover.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 服务注册和发现"><!---->spring cloud 服务注册和发现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/springCloudOpenFeign.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud openFeign"><!---->spring cloud openFeign<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->redis</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer">fxz</a></span><span property="author" content="fxz"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-03-17T06:33:43.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 90 分钟</span><meta property="timeRequired" content="PT90M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category6" role>interview</span><meta property="articleSection" content="interview"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#简单介绍一下-redis" class="router-link-active router-link-exact-active toc-link level3">简单介绍一下 Redis?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-可以做消息队列么" class="router-link-active router-link-exact-active toc-link level3">Redis 可以做消息队列么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-单线程模型了解吗" class="router-link-active router-link-exact-active toc-link level3">Redis 单线程模型了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis6-0-之前为什么不使用多线程" class="router-link-active router-link-exact-active toc-link level3">Redis6.0 之前为什么不使用多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis6-0-之后为何引入了多线程" class="router-link-active router-link-exact-active toc-link level3">Redis6.0 之后为何引入了多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-是如何判断数据是否过期的呢" class="router-link-active router-link-exact-active toc-link level3">Redis 是如何判断数据是否过期的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#过期的数据的删除策略了解么" class="router-link-active router-link-exact-active toc-link level3">过期的数据的删除策略了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-内存淘汰机制了解么" class="router-link-active router-link-exact-active toc-link level3">Redis 内存淘汰机制了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis持久化" class="router-link-active router-link-exact-active toc-link level3">redis持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-事务" class="router-link-active router-link-exact-active toc-link level3">Redis 事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-事务支持原子性吗" class="router-link-active router-link-exact-active toc-link level3">Redis 事务支持原子性吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#如何解决-redis-事务的缺陷" class="router-link-active router-link-exact-active toc-link level3">如何解决 Redis 事务的缺陷？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-bigkey" class="router-link-active router-link-exact-active toc-link level3">redis bigkey？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#大量-key-集中过期问题" class="router-link-active router-link-exact-active toc-link level3">大量 key 集中过期问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#什么是缓存穿透" class="router-link-active router-link-exact-active toc-link level3">什么是缓存穿透？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#什么是缓存雪崩" class="router-link-active router-link-exact-active toc-link level3">什么是缓存雪崩？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#什么是缓存击穿" class="router-link-active router-link-exact-active toc-link level3">什么是缓存击穿?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#_3种常用的缓存读写策略" class="router-link-active router-link-exact-active toc-link level3">3种常用的缓存读写策略？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis内存碎片" class="router-link-active router-link-exact-active toc-link level3">redis内存碎片?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis的有几种数据类型" class="router-link-active router-link-exact-active toc-link level3">Redis的有几种数据类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis为什么快" class="router-link-active router-link-exact-active toc-link level3">redis为什么快？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis默认分多少个数据库" class="router-link-active router-link-exact-active toc-link level3">redis默认分多少个数据库？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#什么是缓存预热" class="router-link-active router-link-exact-active toc-link level3">什么是缓存预热？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-的同步机制了解是什么" class="router-link-active router-link-exact-active toc-link level3">Redis 的同步机制了解是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-cluster槽范围" class="router-link-active router-link-exact-active toc-link level3">Redis Cluster槽范围？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#是否使用过redis-cluster集群-集群的原理是什么" class="router-link-active router-link-exact-active toc-link level3">是否使用过Redis Cluster集群，集群的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-集群架构模式有哪几种" class="router-link-active router-link-exact-active toc-link level3">Redis 集群架构模式有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#说说-redis-哈希槽的概念" class="router-link-active router-link-exact-active toc-link level3">说说 Redis 哈希槽的概念？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" class="router-link-active router-link-exact-active toc-link level3">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis-主从复制的核心原理" class="router-link-active router-link-exact-active toc-link level3">Redis 主从复制的核⼼原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis阻塞" class="router-link-active router-link-exact-active toc-link level3">Redis阻塞</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/04-redis.html#redis分布式锁实现redisson" class="router-link-active router-link-exact-active toc-link level3">Redis分布式锁实现Redisson</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> redis</h1><h3 id="简单介绍一下-redis" tabindex="-1"><a class="header-anchor" href="#简单介绍一下-redis" aria-hidden="true">#</a> 简单介绍一下 Redis?</h3><p><strong>Redis 就是一个使用 C 语言开发的数据库</strong>，与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/tWzxM7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="redis-可以做消息队列么" tabindex="-1"><a class="header-anchor" href="#redis-可以做消息队列么" aria-hidden="true">#</a> Redis 可以做消息队列么？</h3><ul><li><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p></li><li><p>发布 / 订阅模式</p></li><li><p>按照消费者组进行消费</p></li><li><p>消息持久化（ RDB 和 AOF）</p></li></ul><p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p><ul><li><p>还可以使用redis自带的发布订阅模式实现广播消息，即使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</p></li><li><p>还可以使用 list 结构作为队列，rpush生产消息，lpop消费消息。也可以使用BLPOP、BRPOP命令进行阻塞。</p></li><li><p>还可以使用sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p></li></ul><h3 id="redis-单线程模型了解吗" tabindex="-1"><a class="header-anchor" href="#redis-单线程模型了解吗" aria-hidden="true">#</a> Redis 单线程模型了解吗？</h3><p>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 ，这套事件处理模型对应的是 Redis 中的<strong>文件事件处理器</strong>。由于文件事件处理器是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p>既然是单线程，那怎么监听大量的客户端连接呢？</p><p><strong>IO多路复用</strong></p><p>简单理解就是：一个服务端进程可以同时处理多个套接字描述符。</p><ul><li><strong>多路</strong>：多个客户端连接（连接就是套接字描述符）</li><li><strong>复用</strong>：使用单进程就能够实现同时处理多个客户端的连接</li></ul><p>以上是通过增加进程和线程的数量来并发处理多个套接字，免不了上下文切换的开销，而 IO 多路复用只需要一个进程就能够处理多个套接字，从而解决了上下文切换的问题。</p><p>其发展可以分 <strong>select-&gt;poll→epoll</strong> 三个阶段来描述。</p><p><strong>如何简单理解 select/poll/epoll 呢？</strong></p><blockquote><p><strong>举栗说明：</strong></p><p>领导分配员工开发任务，有些员工还没完成。如果领导要每个员工的工作都要验收 check，那在未完成的员工那里，只能阻塞等待，等待他完成之后，再去 check 下一位员工的任务，造成性能问题。</p></blockquote><p><strong>那如何解决这个问题呢？</strong></p><p><strong>1、select</strong></p><blockquote><p>领导找个 Team Leader（后文简称 TL），负责代自己 check 每位员工的开发任务。</p><p>TL 的做法是：遍历问各个员工“完成了么？”，完成的待 CR check 无误后合并到 Git 分支，对于其他未完成的，休息一会儿后再去遍历....</p></blockquote><p>这样存在什么问题呢？</p><ul><li>这个 TL 存在能力短板问题，最多只能管理 1024 个员工</li><li>很多员工的任务没有完成，而且短时间内也完不成的话，TL 还是会不停的去遍历问询，影响效率。</li></ul><p>select 函数：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp1<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span>fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p>select 具有良好的跨平台支持，其缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024。</p><p><strong>2、poll</strong></p><blockquote><p>换一个能力更强的 New Team Leader（后文简称 NTL），可以管理更多的员工，这个 NTL 可以理解为 poll。</p></blockquote><p>poll 函数：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">intpoll</span><span class="token punctuation">(</span>structpollfd<span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token punctuation">{</span> 
<span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">// 需要被检测或选择的文件描述符 </span>
<span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment">// 对文件描述符fd上感兴趣的事件 </span>
<span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment">// 文件描述符fd上当前实际发生的事件</span>
<span class="token punctuation">}</span> <span class="token class-name">pollfd_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>poll 改变了文件描述符集合的描述方式，使用了 pollfd 结构而不是 select 的 fd_set 结构，使得 poll 支持的文件描述符集合限制远大于 select 的 1024。</p><p><strong>3、epoll</strong></p><blockquote><p>在上一步 poll 方式的 NTL 基础上，改进一下 NTL 的办事方法：遍历一次所有员工，如果任务没有完成，告诉员工待完成之后，其应该做 xx 操作（制定一些列的流程规范）。这样 NTL 只需要定期 check 指定的关键节点就好了。这就是 epoll。</p></blockquote><p>Linux 中提供的 epoll 相关函数如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">intepoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">intepoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span><span class="token keyword">int</span> op<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">intepoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span><span class="token keyword">int</span> maxevents<span class="token punctuation">,</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p><p><strong>4、小结</strong></p><ul><li><strong>select</strong> 就是轮询，在 Linux 上限制个数一般为 1024 个</li><li><strong>poll</strong> 解决了 select 的个数限制，但是依然是轮询</li><li><strong>epoll</strong> 解决了个数的限制，同时解决了轮询的方式</li><li></li></ul><p><strong>IO 多路复用在 Redis 中的应用</strong></p><p>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</p><ul><li><strong>文件事件</strong>：Redis 主进程中，主要处理客户端的连接请求与相应。</li><li><strong>时间事件</strong>：fork 出的子进程中，处理如 AOF 持久化任务等。</li></ul><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>IO 多路复用程序负责监听多个套接字并向文件事件分派器传送那些产生了事件的套接字。文件事件分派器接收 IO 多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。示例如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/pCfVD7.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Redis 的 IO 多路复用程序的所有功能都是通过包装常见的 select、poll、evport 和 kqueue 这些 IO 多路复用函数库来实现的，每个 IO 多路复用函数库在 Redis 源码中都有对应的一个单独的文件。</p><p>Redis 为每个 IO 多路复用函数库都实现了相同的 API，所以 IO 多路复用程序的底层实现是可以互换的。如图：</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/zFZcaU.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Redis 把所有连接与读写事件、还有我们没提到的时间事件一起集中管理，并对底层 IO 多路复用机制进行了封装，最终实现了单进程能够处理多个连接以及读写事件。这就是 IO 多路复用在 redis 中的应用。</p><h3 id="redis6-0-之前为什么不使用多线程" tabindex="-1"><a class="header-anchor" href="#redis6-0-之前为什么不使用多线程" aria-hidden="true">#</a> Redis6.0 之前为什么不使用多线程？</h3><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p><p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p><p><strong>那，Redis6.0 之前为什么不使用多线程？</strong></p><p>我觉得主要原因有下面 3 个：</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><h3 id="redis6-0-之后为何引入了多线程" tabindex="-1"><a class="header-anchor" href="#redis6-0-之后为何引入了多线程" aria-hidden="true">#</a> Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。</p><h3 id="redis-是如何判断数据是否过期的呢" tabindex="-1"><a class="header-anchor" href="#redis-是如何判断数据是否过期的呢" aria-hidden="true">#</a> Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><figure><img src="https://minio.pigx.top/oss/2022/07/3lUnPA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="过期的数据的删除策略了解么" tabindex="-1"><a class="header-anchor" href="#过期的数据的删除策略了解么" aria-hidden="true">#</a> 过期的数据的删除策略了解么？</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个：</p><ol><li><p><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</p></li><li><p><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p><p>具体就是Redis每秒10次做的事情：</p><ol><li>测试随机的20个keys进行相关过期检测。</li><li>删除所有已经过期的keys。</li><li>如果有多于25%的keys过期，重复步奏1.</li></ol></li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制</strong>。</p><h3 id="redis-内存淘汰机制了解么" tabindex="-1"><a class="header-anchor" href="#redis-内存淘汰机制了解么" aria-hidden="true">#</a> Redis 内存淘汰机制了解么？</h3><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h3 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> redis持久化</h3><p><a href="https://fxzcloud.tech/article/redis/redis-persistence.html" target="_blank" rel="noopener noreferrer">redis持久化<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h4 id="怎么保证-redis-挂掉之后再重启数据可以进行恢复" tabindex="-1"><a class="header-anchor" href="#怎么保证-redis-挂掉之后再重启数据可以进行恢复" aria-hidden="true">#</a> 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</h4><p>将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis 支持持久化，而且支持两种不同的持久化操作。</p><h4 id="redis持久化的几种方式" tabindex="-1"><a class="header-anchor" href="#redis持久化的几种方式" aria-hidden="true">#</a> redis持久化的几种方式？</h4><p>RDB、AOF、混合持久化。</p><h4 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h4><h5 id="什么是-rdb-持久化" tabindex="-1"><a class="header-anchor" href="#什么是-rdb-持久化" aria-hidden="true">#</a> 什么是 RDB 持久化？</h5><p>通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><h5 id="rdb的优点" tabindex="-1"><a class="header-anchor" href="#rdb的优点" aria-hidden="true">#</a> RDB的优点？</h5><p>rdb是一个紧凑的二进制文件，代表Redis在某个时间点上的数据快照。 适合于备份，全量复制的场景，对于灾难恢复非常有用。</p><p>Redis加载RDB恢复数据的速度远快于AOF方式。</p><h5 id="rdb的缺点" tabindex="-1"><a class="header-anchor" href="#rdb的缺点" aria-hidden="true">#</a> RDB的缺点？</h5><p>RDB没法做到实时的持久化。中途意外终止，会丢失一段时间内的数据。</p><p>RDB需要fork()创建子进程，属于重量级操作，可能导致Redis卡顿若干秒。</p><h4 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h4><h5 id="什么是aof持久化" tabindex="-1"><a class="header-anchor" href="#什么是aof持久化" aria-hidden="true">#</a> 什么是AOF持久化？</h5><p>AOF(append only file)为了解决rdb不能实时持久化的问题，aof来搞定。以独立的日志方式记录把每次命令记录到aof文件中。</p><p>可以通过 appendonly 参数开启：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendonly yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h5 id="aof工作流程" tabindex="-1"><a class="header-anchor" href="#aof工作流程" aria-hidden="true">#</a> AOF工作流程？</h5><p>1.所有写入命令追加到aof_buf缓冲区。</p><p>2.AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3.随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p><p>4.当redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h5 id="为什么aof要先把命令追加到缓存区-aof-buf-中" tabindex="-1"><a class="header-anchor" href="#为什么aof要先把命令追加到缓存区-aof-buf-中" aria-hidden="true">#</a> 为什么AOF要先把命令追加到缓存区(aof_buf)中？</h5><p>Redis使用单线程响应命令，如果每次写入文件命令都直接追加到硬盘，性能就会取决于硬盘的负载。如果使用缓冲区，redis提供多种缓冲区策略，在性能和安全性方面做出平衡。</p><h5 id="aof优点" tabindex="-1"><a class="header-anchor" href="#aof优点" aria-hidden="true">#</a> AOF优点？</h5><p>AOF提供了3种保存策略：每秒保存、跟系统策略、每次操作保存。</p><p>实时性比较高，一般来说会选 择每秒保存，因此意外发生时顶多失去一秒的数据。 文件追加写形式，所以文件很少有损坏问题，如最后意外发生少写数据，可通过redis-check-aof工 具修复。 AOF由于是文本形式，直接采用协议格式，避免二次处理开销，另外对于修改也比较灵活。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p><h5 id="aof缺点" tabindex="-1"><a class="header-anchor" href="#aof缺点" aria-hidden="true">#</a> AOF缺点？</h5><p>AOF文件要比RDB文件大。 AOF冷备没RDB迅速。 由于执行频率比较高，所以负载高时，性能没有RDB好。</p><h5 id="aof-重写了解吗" tabindex="-1"><a class="header-anchor" href="#aof-重写了解吗" aria-hidden="true">#</a> AOF 重写了解吗？</h5><p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><h4 id="混合持久化-优缺点" tabindex="-1"><a class="header-anchor" href="#混合持久化-优缺点" aria-hidden="true">#</a> 混合持久化？优缺点？</h4><p>一般来说我们的线上都会采取混合持久化。redis4.0以后添加了新的混合持久化方式。如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。</p><p><strong>优点：</strong></p><p>在快速加载的同时，避免了丢失过更多的数据。</p><p><strong>缺点：</strong></p><p>由于混合了两种格式，所以可读性差。 兼容性，需要4.0以后才支持。</p><h3 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务" aria-hidden="true">#</a> Redis 事务？</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><p>使用 <code>MULTI</code> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code>命令将执行所有命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><p><code>WATCH</code> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p><h3 id="redis-事务支持原子性吗" tabindex="-1"><a class="header-anchor" href="#redis-事务支持原子性吗" aria-hidden="true">#</a> Redis 事务支持原子性吗？</h3><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p><p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><h3 id="如何解决-redis-事务的缺陷" tabindex="-1"><a class="header-anchor" href="#如何解决-redis-事务的缺陷" aria-hidden="true">#</a> 如何解决 Redis 事务的缺陷？</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器<strong>一次性执行完成，大幅减小了网络开销</strong>。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，<strong>保证了操作不会被其他指令插入或打扰。</strong></p><p>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的。因此，严格来说，通过 <strong>Lua 脚本来批量执行 Redis 命令也是不满足原子性的</strong>。</p><h3 id="redis-bigkey" tabindex="-1"><a class="header-anchor" href="#redis-bigkey" aria-hidden="true">#</a> redis bigkey？</h3><p><a href="https://fxzcloud.tech/article/redis/redis-prod.html" target="_blank" rel="noopener noreferrer">redis处理大key<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。</p><p>具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个。</p><p><strong>bigkey 有什么危害？</strong></p><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p>bigkey 的主要影响有：</p><p>网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。</p><p>超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</p><p>导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响。</p><h3 id="大量-key-集中过期问题" tabindex="-1"><a class="header-anchor" href="#大量-key-集中过期问题" aria-hidden="true">#</a> 大量 key 集中过期问题？</h3><p>对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p><p><strong>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</strong></p><p>如何解决呢？下面是两种常见的方法：</p><ol><li>给 key 设置随机过期时间。</li><li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><h3 id="什么是缓存穿透" tabindex="-1"><a class="header-anchor" href="#什么是缓存穿透" aria-hidden="true">#</a> 什么是缓存穿透？</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p><p>举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><p><strong>有哪些解决办法？</strong></p><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。</p><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下</p><figure><img src="https://minio.pigx.top/oss/2022/07/tTYbJw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong></p><h3 id="什么是缓存雪崩" tabindex="-1"><a class="header-anchor" href="#什么是缓存雪崩" aria-hidden="true">#</a> 什么是缓存雪崩？</h3><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p><p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p><p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><p><strong>有哪些解决办法？</strong></p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h3 id="什么是缓存击穿" tabindex="-1"><a class="header-anchor" href="#什么是缓存击穿" aria-hidden="true">#</a> 什么是缓存击穿?</h3><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/hLOy5z.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li><strong>设置热点数据永不过期</strong>：对于一些热点数据，可以考虑设置永不过期，或者采用懒加载的策略，在缓存失效时异步更新缓存数据，而不是立即删除数据。</li><li><strong>使用互斥锁</strong>：在缓存失效时，只允许一个线程去查询数据库并更新缓存，其他线程需要等待这个线程完成后再获取数据。</li><li><strong>预先加载</strong>：在系统启动时或者定时任务中预先加载热点数据到缓存中，避免在缓存失效时出现大量请求同时访问。</li><li><strong>使用分布式缓存</strong>：采用分布式缓存集群，将热点数据均匀分布在不同节点上，减少单点压力。</li></ul><h3 id="_3种常用的缓存读写策略" tabindex="-1"><a class="header-anchor" href="#_3种常用的缓存读写策略" aria-hidden="true">#</a> 3种常用的缓存读写策略？</h3><ul><li><p>Cache Aside Pattern（旁路缓存模式）</p><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p><p><strong>写</strong> ：</p><p>1.先更新 DB</p><p>2.然后直接删除 cache 。</p><p><strong>读</strong> :</p><p>1.从 cache 中读取数据，读取到就直接返回</p><p>2.cache中读取不到的话，就从 DB 中读取数据返回</p><p>3.再把数据放到 cache 中。</p><p><strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong></p><p><strong>答案：</strong> 不行！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。</p></li></ul><blockquote><p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p></blockquote><p><strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong></p><p><strong>答案：</strong> 可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p><p><strong>Cache Aside Pattern 的缺陷</strong>。</p><p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入cache 中。</p><p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><p>1.数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</p><p>2.可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</p><ul><li><p><strong>Read/Write Through Pattern（读写穿透）</strong></p><p>Read/Write Through Pattern 中服务端<strong>把 cache 视为主要数据存储</strong>，从中读取数据并将数据写入DB中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p><p><strong>写（Write Through）：</strong></p><p>1.先查 cache，cache 中不存在，直接更新 DB。</p><p>2.cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</p><p><strong>读(Read Through)：</strong></p><p>1.从 cache 中读取数据，读取到就直接返回 。</p><p>2.读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</p></li><li><p>Write Behind Pattern（异步缓存写入）</p><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p><p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p></li></ul><h3 id="redis内存碎片" tabindex="-1"><a class="header-anchor" href="#redis内存碎片" aria-hidden="true">#</a> redis内存碎片?</h3><p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p><p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p><p><strong>为什么会有 Redis 内存碎片?</strong></p><p>Redis 内存碎片产生比较常见的 2 个原因：</p><p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p><p>**2、频繁修改 Redis 中的数据也会产生内存碎片。**当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p><p><strong>怎么解决：</strong></p><ol><li><strong>重启Redis</strong>：一种简单粗暴的方法是通过重启Redis来清理内存碎片。重启后内存会被重新整理，碎片问题可能会得到缓解。</li><li><strong>使用内存碎片整理工具</strong>：Redis 4.0 版本引入了 <code>MEMORY PURGE</code> 命令，可以用于整理内存碎片。该命令会尝试重新分配已使用内存的页面，以便更好地利用内存空间。</li><li><strong>使用 <code>REWRITE</code> 命令</strong>：<code>REWRITE</code> 命令可以对数据库进行重写，将现有的数据重新写入新的 RDB 文件中，再重新载入这个 RDB 文件，可以达到一定程度的内存整理效果。</li><li><strong>使用 <code>MIGRATE</code> 命令</strong>：<code>MIGRATE</code> 命令可以将 key 从一个 Redis 实例迁移到另一个实例，通过这种方式也可以间接实现内存整理。</li><li><strong>避免频繁增删数据</strong>：尽量避免频繁对数据进行增删操作，可以减少内存碎片的产生。如果需要频繁更新数据，可以考虑使用 <code>HASH</code> 数据结构代替 <code>STRING</code> 数据结构，减少碎片化的可能性。</li><li><strong>使用合适的过期策略</strong>：设置合理的过期时间，及时删除不再需要的数据，释放被占用的内存空间，减少碎片。</li></ol><h3 id="redis的有几种数据类型" tabindex="-1"><a class="header-anchor" href="#redis的有几种数据类型" aria-hidden="true">#</a> Redis的有几种数据类型？</h3><p><a href="https://fxzcloud.tech/article/redis/redis-data-types.html" target="_blank" rel="noopener noreferrer">redis常见数据类型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>基础：字符串（String）、哈希（hash)、列表（list)、集合(set)、有序集合(zset)。</p><p>还有HyperLogLog、流、地理坐标等</p><h3 id="redis为什么快" tabindex="-1"><a class="header-anchor" href="#redis为什么快" aria-hidden="true">#</a> redis为什么快？</h3><p>redis使用了单线程架构和I/O多路复用模型模型。</p><p>纯内存访问。</p><p>由于是单线程避免了线程上下文切换带来的资源消耗。</p><p><strong>优秀的数据结构支持</strong>：Redis 内置了丰富的数据结构，如字符串、哈希、列表、集合、有序集合等，这些数据结构的实现经过优化，可以高效地满足各种数据操作需求。</p><h3 id="redis默认分多少个数据库" tabindex="-1"><a class="header-anchor" href="#redis默认分多少个数据库" aria-hidden="true">#</a> redis默认分多少个数据库？</h3><p>16</p><h3 id="什么是缓存预热" tabindex="-1"><a class="header-anchor" href="#什么是缓存预热" aria-hidden="true">#</a> 什么是缓存预热？</h3><p>就是系统上线后，提前将相关数据加载到缓存系统，避免用户先查库，然后在缓存。</p><h3 id="redis-的同步机制了解是什么" tabindex="-1"><a class="header-anchor" href="#redis-的同步机制了解是什么" aria-hidden="true">#</a> Redis 的同步机制了解是什么？</h3><p>Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区， RDB 文件全部同步到复制节点，复制节点接受完成后将 RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p><h3 id="redis-cluster槽范围" tabindex="-1"><a class="header-anchor" href="#redis-cluster槽范围" aria-hidden="true">#</a> Redis Cluster槽范围？</h3><p>0~16383</p><h3 id="是否使用过redis-cluster集群-集群的原理是什么" tabindex="-1"><a class="header-anchor" href="#是否使用过redis-cluster集群-集群的原理是什么" aria-hidden="true">#</a> 是否使用过Redis Cluster集群，集群的原理是什么？</h3><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号 在 0~16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p><h3 id="redis-集群架构模式有哪几种" tabindex="-1"><a class="header-anchor" href="#redis-集群架构模式有哪几种" aria-hidden="true">#</a> Redis 集群架构模式有哪几种？</h3><p>Redis 集群架构是支持单节点单机模式的，也支持一主多从的主从结构，还支持带有哨兵的集群部署模式。</p><h3 id="说说-redis-哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#说说-redis-哈希槽的概念" aria-hidden="true">#</a> 说说 Redis 哈希槽的概念？</h3><p>Redis 集群并没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有 16384（2^14）个哈 希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><h3 id="假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" aria-hidden="true">#</a> 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ol><li>使用 keys 命令（不用，会阻塞！）</li></ol><p>直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。</p><p>而且 Redis 是单线程，keys 指令会导 致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产 环境是不允许的。</p><p>除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条 件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。</p><ol start="2"><li>使用 scan 命令</li></ol><p>scan 指令可以无阻塞的提取出指定模式的 key 列表， 但 是会有一定的重复概率， 在客户端做一次去重就可以了， 但是整体所花费的时间 会比直接用 keys 指令长。</p><h3 id="redis-主从复制的核心原理" tabindex="-1"><a class="header-anchor" href="#redis-主从复制的核心原理" aria-hidden="true">#</a> Redis 主从复制的核⼼原理</h3><p>通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接 受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数 据库。</p><p>全量复制：</p><ol><li><p>主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬盘IO的</p></li><li><p>主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗</p></li><li><p>从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏ bgrewriteaof，也会带来额外的消耗</p></li></ol><p>部分复制：</p><ol><li><p>复制偏移量：执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset</p></li><li><p>复制积压缓冲区：主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。</p></li><li><p>服务器运⾏ID(runid)：每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时候，就是根据运⾏ID来判断同步的进度：</p></li></ol><p>○ 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p><p>○ 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进⾏全量复制。</p><h3 id="redis阻塞" tabindex="-1"><a class="header-anchor" href="#redis阻塞" aria-hidden="true">#</a> Redis阻塞</h3><p><strong>命令阻塞</strong></p><p>使用不当的命令造成客户端阻塞：</p><ul><li>keys ：获取所有的 key 操作；</li><li>Hgetall：返回哈希表中所有的字段和；</li><li>smembers：返回集合中的所有成员；</li></ul><p>这些命令时间复杂度是O(n)，有时候也会全表扫描，随着n的增大耗时也会越大从而导致客户端阻塞。</p><p><strong>SAVE 阻塞</strong></p><p>大家都知道 Redis 在进行 RDB 快照的时候，会调用系统函数 fork() ，创建一个子线程来完成临时文件的写入，而触发条件正是配置文件中的 save 配置。</p><p>当达到我们的配置时，就会触发 bgsave 命令创建快照，这种方式是不会阻塞主线程的，而手动执行 save 命令会在主线程中执行，<strong>阻塞</strong>主线程。</p><p><strong>同步持久化</strong></p><p>当 Redis 直接记录 AOF 日志时，如果有大量的写操作，并且配置为同步持久化</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>appendfsync always
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>即每次发生数据变更会被立即记录到磁盘，因为写磁盘比较耗时，性能较差，所以有时会阻塞主线程。</p><p><strong>AOF 重写</strong></p><ol><li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li><li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li><li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li></ol><p>阻塞就是出现在第2步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p><p><strong>AOF 日志</strong></p><p>AOF 的日志记录不像关系型数据库那样在执行命令之前记录日志（方便故障恢复），而是采用先执行命令后记录日志的方式。</p><p>原因就是 AOF 记录日志是不会对命令进行语法检查的，这样就能减少额外的检查开销，不会对当前命令的执行产生阻塞，但可能会给下一个操作带来阻塞风险。</p><p><strong>这是因为 AOF 日志也是在主线程中执行的</strong>，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p><p><strong>大 Key 问题</strong></p><p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p><p>大 key 造成的阻塞问题如下：</p><ul><li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li></li></ul><p><strong>查找大 key</strong></p><p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p><ul><li><p>我们还可以使用 SCAN 命令来查找大 key；</p></li><li><p>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</p></li><li><ul><li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li><li></li></ul></li></ul><p><strong>删除大 key</strong></p><p>删除操作的本质是要释放键值对占用的内存空间。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis <strong>主线程的阻塞</strong>，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><blockquote><p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p></blockquote><p><strong>清空数据库</strong></p><p>清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p><p><strong>集群扩容</strong></p><p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于<strong>半自动</strong>状态，需要人工介入。</p><p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是<strong>同步</strong>操作。</p><p>执行迁移时，两端的 Redis 均会进入时长不等的<strong>阻塞</strong>状态，对于小Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p><h3 id="redis分布式锁实现redisson" tabindex="-1"><a class="header-anchor" href="#redis分布式锁实现redisson" aria-hidden="true">#</a> Redis分布式锁实现Redisson</h3><h4 id="redisson如何加锁并保证加锁的原子性" tabindex="-1"><a class="header-anchor" href="#redisson如何加锁并保证加锁的原子性" aria-hidden="true">#</a> redisson如何加锁并保证加锁的原子性？</h4><p>1: 判断key是否存在</p><p>2: 不存在的话：</p><ul><li>设置hash结构字段自增，表示重入的次数。</li><li>设置key的过期时间。</li></ul><p>3: 存在的话：</p><ul><li>通过hash结构判断是否是当前线程，是否话重入加锁。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过tryLockInnerAsync方法的实现可以看出，最终加锁是通过lua脚本来实现加锁的，redis在执行lua脚本的时候是可以保证加锁的原子性的，所以Redisson实现加锁的原子性是依赖lua脚本来实现的。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/cWHHZc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/RjAqNb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="为什么需要设置加锁key的过期时间" tabindex="-1"><a class="header-anchor" href="#为什么需要设置加锁key的过期时间" aria-hidden="true">#</a> 为什么需要设置加锁key的过期时间</h4><p>为了避免死锁。</p><p>redisson提供了看门狗的逻辑，如果不设置过期时间的话，redisson会把key的过期时间设置为30s，然后定时任务轮训去续期key。</p><p>这会导致一个问题，只要客户端不宕机或者释放key的话，key会一直存在，导致死锁。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/HP1ydR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过上面可以看到，如果不设置过期时间的话，会通过scheduleExpirationRenewal进行续约，也就是看门狗的逻辑。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/RKJQ2V.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/CU2xVH.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="如何实现可重入加锁" tabindex="-1"><a class="header-anchor" href="#如何实现可重入加锁" aria-hidden="true">#</a> 如何实现可重入加锁</h4><p>通过上述hash结构，维护一个计数器即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何主动释放锁和避免其它线程释放了自己加的锁" tabindex="-1"><a class="header-anchor" href="#如何主动释放锁和避免其它线程释放了自己加的锁" aria-hidden="true">#</a> 如何主动释放锁和避免其它线程释放了自己加的锁</h4><p>unLock方法。</p><p>可以看到，他会判断hash结构中，锁是否由当前线程持有，然后判断重入次数，次数为0的时候释放掉锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (counter &gt; 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return 0; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;del&#39;, KEYS[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return 1; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil;&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getChannelName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LockPubSub</span><span class="token punctuation">.</span><span class="token constant">UNLOCK_MESSAGE</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现超时自动释放锁" tabindex="-1"><a class="header-anchor" href="#如何实现超时自动释放锁" aria-hidden="true">#</a> 如何实现超时自动释放锁</h4><p>综上，设置锁的过期时间，redisson就不会采用看门狗的方式续期，key到期自动释放了。</p><h4 id="如何实现不同线程加锁的互斥" tabindex="-1"><a class="header-anchor" href="#如何实现不同线程加锁的互斥" aria-hidden="true">#</a> 如何实现不同线程加锁的互斥</h4><p>lua脚本的原子性保证了多个线程只会加锁成功一次，同时存了线程id信息，保证线程间加锁</p><p>互斥。</p><h4 id="加锁失败之后如何实现阻塞等待加锁" tabindex="-1"><a class="header-anchor" href="#加锁失败之后如何实现阻塞等待加锁" aria-hidden="true">#</a> 加锁失败之后如何实现阻塞等待加锁</h4><p>执行死循环（自旋）的方式来不停地通过tryAcquire方法来尝试加锁，直到加锁成功之后才会跳出死循环，如果一直没有成功加锁，那么就会一直旋转下去，所谓的阻塞，实际上就是自旋加锁的方式。</p><p>但是这种阻塞可能会产生问题，因为如果其它线程释放锁失败，那么这个阻塞加锁的线程会一直阻塞加锁，这肯定会出问题的。所以有没有能够可以指定阻塞的时间，如果超过一定时间还未加锁成功的话，那么就放弃加锁的方法。即推荐使用tryLock。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">boolean</span> interruptibly<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// lock acquired</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RedissonLockEntry</span> entry<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            entry <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getInterrupted</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            entry <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// lock acquired</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// waiting for message</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptibly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        entry<span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquireUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token function">unsubscribe</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        get(lockAsync(leaseTime, unit));</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现阻塞等待一定时间还未加锁成功就放弃加" tabindex="-1"><a class="header-anchor" href="#如何实现阻塞等待一定时间还未加锁成功就放弃加" aria-hidden="true">#</a> 如何实现阻塞等待一定时间还未加锁成功就放弃加</h4><p>tryLock方法。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/ka90Hg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="如何实现公平锁" tabindex="-1"><a class="header-anchor" href="#如何实现公平锁" aria-hidden="true">#</a> 如何实现公平锁</h4><p>先到先得。</p><p>线程来加锁的时候，如果加锁失败了，那么会将线程扔到一个集合中，这样就按照加锁的顺序给线程排队，set集合的头部的线程就代表了接下来能够加锁成功的线程。</p><p>当有线程释放了锁之后，其它加锁失败的线程就会来继续加锁，加锁之前会先判断一下set集合的头部的线程跟当前要加锁的线程是不是同一个，如果是的话，那就加锁成功，如果不是的话，那么就加锁失败，这样就实现了加锁的顺序性。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;while true do &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;local firstThreadId2 = redis.call(&#39;lindex&#39;, KEYS[2], 0);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;if firstThreadId2 == false then &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;break;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;local timeout = tonumber(redis.call(&#39;zscore&#39;, KEYS[3], firstThreadId2));&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;if timeout &lt;= tonumber(ARGV[3]) then &quot;</span> <span class="token operator">+</span>
        <span class="token comment">// remove the item from the queue and timeout set</span>
        <span class="token comment">// NOTE we do not alter any other timeout</span>
        <span class="token string">&quot;redis.call(&#39;zrem&#39;, KEYS[3], firstThreadId2);&quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;redis.call(&#39;lpop&#39;, KEYS[2]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;break;&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>

<span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;and ((redis.call(&#39;exists&#39;, KEYS[2]) == 0) &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;or (redis.call(&#39;lindex&#39;, KEYS[2], 0) == ARGV[2])) then &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;lpop&#39;, KEYS[2]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;zrem&#39;, KEYS[3], ARGV[2]);&quot;</span> <span class="token operator">+</span>

    <span class="token comment">// decrease timeouts for all waiting in the queue</span>
    <span class="token string">&quot;local keys = redis.call(&#39;zrange&#39;, KEYS[3], 0, -1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;for i = 1, #keys, 1 do &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;redis.call(&#39;zincrby&#39;, KEYS[3], -tonumber(ARGV[4]), keys[i]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>

    <span class="token string">&quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);&quot;</span> <span class="token operator">+</span>
    <span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return 1;&quot;</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="如何实现读写锁" tabindex="-1"><a class="header-anchor" href="#如何实现读写锁" aria-hidden="true">#</a> 如何实现读写锁</h4><p>Redisson通过RedissonReadWriteLock类来实现读写锁的功能，通过这个类可以获取到读锁或者写锁，所以真正的加锁的逻辑是由读锁和写锁实现的。</p><p>在读写锁的实现中，会往hash数据结构中多维护一个mode的字段，来表示当前加锁的模式。</p><p>所以能够实现读写锁，最主要是因为维护了一个加锁模式的字段mode，这样有线程来加锁的时候，就能根据当前加锁的模式结合读写的特性来判断要不要让当前来加锁的线程加锁成功。</p><p>如果没有加锁，那么不论是读锁还是写锁都能加成功，成功之后根据锁的类型维护mode字段。 如果模式是读锁，那么加锁线程是来加读锁的，就让它加锁成功。 如果模式是读锁，那么加锁线程是来加写锁的，就让它加锁失败。 如果模式是写锁，那么加锁线程是来加写锁的，就让它加锁失败（加锁线程自己除外）。 如果模式是写锁，那么加锁线程是来加读锁的，就让它加锁失败（加锁线程自己除外）。</p><h4 id="如何实现批量加锁-联锁" tabindex="-1"><a class="header-anchor" href="#如何实现批量加锁-联锁" aria-hidden="true">#</a> 如何实现批量加锁(联锁)</h4><p>批量加锁的意思就是同时加几个锁，只有这些锁都算加成功了，才是真正的加锁成功。</p><p>redisson遍历这些锁进行加锁。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2024/03/17/joBrSg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="红锁为了解决什么问题" tabindex="-1"><a class="header-anchor" href="#红锁为了解决什么问题" aria-hidden="true">#</a> 红锁为了解决什么问题</h4><p>集群情况下，那就是客户端对原先的主节点加锁，成功之后还没有来得及同步给从节点，主节点宕机了，从节点变成了主节点，此时从节点是没有加锁信息的，如果有其它的客户端来加锁，是能够加锁成功的。</p><p>红锁算法的基本思想如下：</p><ol><li>获取当前时间戳、唯一标识符和锁的过期时间。</li><li>尝试在多个独立的Redis实例（节点）上获取锁，每个实例对应一个资源。</li><li>如果在<strong>大多数实例</strong>上成功获取到锁，并且总共花费的时间<strong>没有超过锁的过期时间</strong>，则认为获取锁成功。</li><li>如果获取锁成功，执行相关业务逻辑；否则，释放已获取的锁。</li></ol></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/springboot4/edit/main/src/article/offer/04-redis.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 2235602974@qq.com">付绪壮</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-f9138082.js" defer></script>
  </body>
</html>
