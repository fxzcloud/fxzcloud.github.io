<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?87d678935e4b33455c0390543e7a759d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><title>并发编程 | 冤种说java</title><meta name="description" content="「流水不争先 争的是滔滔不绝」">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-cde8b1ec.css" as="style"><link rel="stylesheet" href="/assets/style-cde8b1ec.css">
    <link rel="modulepreload" href="/assets/app-f9138082.js"><link rel="modulepreload" href="/assets/framework-159025ca.js"><link rel="modulepreload" href="/assets/03-juc.html-bea44136.js"><link rel="modulepreload" href="/assets/03-juc.html-5fb42da9.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="冤种说java"><!----><span class="site-name hide-in-pad">冤种说java</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/source-code/nacos/clusterSync.html" class="nav-link" aria-label="笔记"><span class="font-icon icon iconfont icon-activity" style=""></span>笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/" class="nav-link active" aria-label="博客"><span class="font-icon icon iconfont icon-blog" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/offer/" class="nav-link active" aria-label="八股"><span class="font-icon icon iconfont icon-shell" style=""></span>八股<!----></a></div><div class="nav-item hide-in-mobile"><a href="/me/other.html" class="nav-link" aria-label="其他"><span class="font-icon icon iconfont icon-share" style=""></span>其他<!----></a></div><div class="nav-item hide-in-mobile"><a href="/about.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-alias" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-software" style=""></span><span class="title">nacos</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/nacos/clusterSync.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos集群同步"><!---->nacos集群同步<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/config.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos配置中心"><!---->nacos配置中心<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/discoverAndSubscribe.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务发现和订阅机制"><!---->nacos服务发现和订阅机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/healthCheck.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos健康检查机制"><!---->nacos健康检查机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/register.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务注册"><!---->nacos服务注册<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-alias" style=""></span><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/spring/LookUp%E3%80%81DependsOn%E3%80%81Lazy.html" class="nav-link sidebar-link sidebar-page" aria-label="spring常见注解"><!---->spring常见注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpingInject.html" class="nav-link sidebar-link sidebar-page" aria-label="spring依赖注入"><!---->spring依赖注入<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Cache.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cache注解驱动"><!---->spring cache注解驱动<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Event.html" class="nav-link sidebar-link sidebar-page" aria-label="spring event"><!---->spring event<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20MVC.html" class="nav-link sidebar-link sidebar-page" aria-label="spring mvc源码分析"><!---->spring mvc源码分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring@Async.html" class="nav-link sidebar-link sidebar-page" aria-label="spring异步@Async"><!---->spring异步@Async<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringAop.html" class="nav-link sidebar-link sidebar-page" aria-label="spring aop"><!---->spring aop<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringBeanLIfeCycle.html" class="nav-link sidebar-link sidebar-page" aria-label="spring bean的生命周期"><!---->spring bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringConfig.html" class="nav-link sidebar-link sidebar-page" aria-label="spring配置文件"><!---->spring配置文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringTransaction.html" class="nav-link sidebar-link sidebar-page" aria-label="spring事务"><!---->spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-template" style=""></span><span class="title">spring boot</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringBoot/config.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot配置加载"><!---->spring boot配置加载<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringBoot/start.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot启动流程"><!---->spring boot启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-module" style=""></span><span class="title">spring cloud</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringCloudCommon/configRefresh.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 配置动态刷新"><!---->spring cloud 配置动态刷新<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/loadBalancing.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud loadBalanced"><!---->spring cloud loadBalanced<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/registerAndDiscover.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 服务注册和发现"><!---->spring cloud 服务注册和发现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/springCloudOpenFeign.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud openFeign"><!---->spring cloud openFeign<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->并发编程</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer">fxz</a></span><span property="author" content="fxz"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-03-17T06:33:43.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 114 分钟</span><meta property="timeRequired" content="PT114M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category6" role>interview</span><meta property="articleSection" content="interview"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#什么是线程和进程" class="router-link-active router-link-exact-active toc-link level3">什么是线程和进程?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#请简要描述线程与进程的关系-区别及优缺点" class="router-link-active router-link-exact-active toc-link level3">请简要描述线程与进程的关系,区别及优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#程序计数器为什么是私有的" class="router-link-active router-link-exact-active toc-link level3">程序计数器为什么是私有的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#虚拟机栈和本地方法栈为什么是私有的" class="router-link-active router-link-exact-active toc-link level3">虚拟机栈和本地方法栈为什么是私有的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#一句话简单介绍堆和方法区" class="router-link-active router-link-exact-active toc-link level3">一句话简单介绍堆和方法区？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说并发与并行的区别" class="router-link-active router-link-exact-active toc-link level3">说说并发与并行的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#为什么要使用多线程呢" class="router-link-active router-link-exact-active toc-link level3">为什么要使用多线程呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#使用多线程可能带来什么问题" class="router-link-active router-link-exact-active toc-link level3">使用多线程可能带来什么问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说线程的生命周期和状态" class="router-link-active router-link-exact-active toc-link level3">说说线程的生命周期和状态?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#什么是上下文切换" class="router-link-active router-link-exact-active toc-link level3">什么是上下文切换?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#什么是线程死锁-如何避免死锁" class="router-link-active router-link-exact-active toc-link level3">什么是线程死锁 ? 如何避免死锁 ?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说-sleep-方法和-wait-方法区别和共同点" class="router-link-active router-link-exact-active toc-link level3">说说 sleep() 方法和 wait() 方法区别和共同点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="router-link-active router-link-exact-active toc-link level3">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active toc-link level3">说一说自己对于 synchronized 关键字的了解?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active toc-link level3">说说自己是怎么使用 synchronized 关键字?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#构造方法可以使用-synchronized-关键字修饰么" class="router-link-active router-link-exact-active toc-link level3">构造方法可以使用 synchronized 关键字修饰么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#讲一下-synchronized-关键字的底层原理" class="router-link-active router-link-exact-active toc-link level3">讲一下 synchronized 关键字的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="router-link-active router-link-exact-active toc-link level3">说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#谈谈-synchronized-和-reentrantlock-的区别" class="router-link-active router-link-exact-active toc-link level3">谈谈 synchronized 和 ReentrantLock 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#讲讲cpu-缓存模型" class="router-link-active router-link-exact-active toc-link level3">讲讲CPU 缓存模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#缓存一致性协议" class="router-link-active router-link-exact-active toc-link level3">缓存一致性协议</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#讲一下-jmm-java-内存模型" class="router-link-active router-link-exact-active toc-link level3">讲一下 JMM(Java 内存模型)？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#并发编程的三个重要特性" class="router-link-active router-link-exact-active toc-link level3">并发编程的三个重要特性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说-synchronized-关键字和-volatile-关键字的区别" class="router-link-active router-link-exact-active toc-link level3">说说 synchronized 关键字和 volatile 关键字的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#为什么要用线程池" class="router-link-active router-link-exact-active toc-link level3">为什么要用线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#实现-runnable-接口和-callable-接口的区别" class="router-link-active router-link-exact-active toc-link level3">实现 Runnable 接口和 Callable 接口的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#执行-execute-方法和-submit-方法的区别是什么呢" class="router-link-active router-link-exact-active toc-link level3">执行 execute()方法和 submit()方法的区别是什么呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#如何创建线程池" class="router-link-active router-link-exact-active toc-link level3">如何创建线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#threadpoolexecutor构造函数重要参数分析" class="router-link-active router-link-exact-active toc-link level3">ThreadPoolExecutor构造函数重要参数分析？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#juc-包中的原子类是哪-4-类" class="router-link-active router-link-exact-active toc-link level3">JUC 包中的原子类是哪 4 类?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#能不能给我简单介绍一下-atomicinteger-类的原理" class="router-link-active router-link-exact-active toc-link level3">能不能给我简单介绍一下 AtomicInteger 类的原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#介绍一下aqs" class="router-link-active router-link-exact-active toc-link level3">介绍一下AQS?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#shutdown-和shutdownnow-的区别" class="router-link-active router-link-exact-active toc-link level3">shutdown()和shutdownNow()的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#isterminated-和isshutdown-的区别" class="router-link-active router-link-exact-active toc-link level3">isTerminated()和isShutdown()的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说一下线程之间是如何通信的" class="router-link-active router-link-exact-active toc-link level3">说一下线程之间是如何通信的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#cas的原理以及缺点" class="router-link-active router-link-exact-active toc-link level3">CAS的原理以及缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#引用类型有哪些-有什么区别" class="router-link-active router-link-exact-active toc-link level3">引用类型有哪些？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#happen-before规则" class="router-link-active router-link-exact-active toc-link level3">happen-before规则？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#线程的sleep、wait、join、yield如何使用" class="router-link-active router-link-exact-active toc-link level3">线程的sleep、wait、join、yield如何使用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#threadlocal的原理是什么-使用场景有哪些" class="router-link-active router-link-exact-active toc-link level3">ThreadLocal的原理是什么，使用场景有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#threadlocal有哪些内存泄露问题-如何避免" class="router-link-active router-link-exact-active toc-link level3">ThreadLocal有哪些内存泄露问题，如何避免？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#volatile的可见性和禁止指令重排序怎么实现的" class="router-link-active router-link-exact-active toc-link level3">volatile的可见性和禁止指令重排序怎么实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#concurrenthashmap底层原理是什么" class="router-link-active router-link-exact-active toc-link level3">ConcurrentHashMap底层原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" class="router-link-active router-link-exact-active toc-link level3">线程池中阻塞队列的作⽤？为什么是先添加队列⽽不是先创建最⼤线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#reentrantlock中的公平锁和非公平锁的底层实现" class="router-link-active router-link-exact-active toc-link level3">ReentrantLock中的公平锁和⾮公平锁的底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#reentrantlock中trylock-和lock-方法的区别" class="router-link-active router-link-exact-active toc-link level3">ReentrantLock中tryLock()和lock()⽅法的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#countdownlatch和semaphore的区别和底层原理" class="router-link-active router-link-exact-active toc-link level3">CountDownLatch和Semaphore的区别和底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#线程池如何知道一个线程的任务已经执行完成" class="router-link-active router-link-exact-active toc-link level3">线程池如何知道一个线程的任务已经执行完成</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#wait-和-notify-这个为什么要在-synchronized-代码块中" class="router-link-active router-link-exact-active toc-link level3">wait 和 notify 这个为什么要在 synchronized 代码块中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#java中interrupted-和-isinterruptedd方法的区别" class="router-link-active router-link-exact-active toc-link level3">Java中interrupted 和 isInterruptedd方法的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#synchronizedmap和concurrenthashmap有什么区别" class="router-link-active router-link-exact-active toc-link level3">SynchronizedMap和ConcurrentHashMap有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#线程池核心线程数怎么设置呢" class="router-link-active router-link-exact-active toc-link level3">线程池核心线程数怎么设置呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#java线程池中队列常用类型有哪些" class="router-link-active router-link-exact-active toc-link level3">Java线程池中队列常用类型有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#说说cyclicbarrier和countdownlatch的区别" class="router-link-active router-link-exact-active toc-link level3">说说CyclicBarrier和CountDownLatch的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#线程类的构造方法、静态块是被哪个线程调用的" class="router-link-active router-link-exact-active toc-link level3">线程类的构造⽅法、静态块是被哪个线程调⽤的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#死锁与活锁的区别-死锁与锁饥饿的区别" class="router-link-active router-link-exact-active toc-link level3">死锁与活锁的区别，死锁与锁饥饿的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#volatile实现可见性的原理" class="router-link-active router-link-exact-active toc-link level3">volatile实现可见性的原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#是否可以把一个数组修饰为volatile" class="router-link-active router-link-exact-active toc-link level3">是否可以把一个数组修饰为volatile?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-juc.html#cpu使用率过高问题排查" class="router-link-active router-link-exact-active toc-link level3">CPU使用率过高问题排查</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程" aria-hidden="true">#</a> 并发编程</h1><h3 id="什么是线程和进程" tabindex="-1"><a class="header-anchor" href="#什么是线程和进程" aria-hidden="true">#</a> 什么是线程和进程?</h3><p><strong>何为进程</strong>?</p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p><strong>何为线程</strong>?</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。 与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="请简要描述线程与进程的关系-区别及优缺点" tabindex="-1"><a class="header-anchor" href="#请简要描述线程与进程的关系-区别及优缺点" aria-hidden="true">#</a> 请简要描述线程与进程的关系,区别及优缺点？</h3><p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈和 本地方法栈。</p><p>总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。进程作为资源分配的基本单位，线程作为资源调度的基本单位。</p><h3 id="程序计数器为什么是私有的" tabindex="-1"><a class="header-anchor" href="#程序计数器为什么是私有的" aria-hidden="true">#</a> 程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的" tabindex="-1"><a class="header-anchor" href="#虚拟机栈和本地方法栈为什么是私有的" aria-hidden="true">#</a> 虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的</p><h3 id="一句话简单介绍堆和方法区" tabindex="-1"><a class="header-anchor" href="#一句话简单介绍堆和方法区" aria-hidden="true">#</a> 一句话简单介绍堆和方法区？</h3><p>​ 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="说说并发与并行的区别" tabindex="-1"><a class="header-anchor" href="#说说并发与并行的区别" aria-hidden="true">#</a> 说说并发与并行的区别?</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行</li></ul><h3 id="为什么要使用多线程呢" tabindex="-1"><a class="header-anchor" href="#为什么要使用多线程呢" aria-hidden="true">#</a> 为什么要使用多线程呢?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li></ul><h3 id="使用多线程可能带来什么问题" tabindex="-1"><a class="header-anchor" href="#使用多线程可能带来什么问题" aria-hidden="true">#</a> 使用多线程可能带来什么问题?</h3><p>​ 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h3 id="说说线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#说说线程的生命周期和状态" aria-hidden="true">#</a> 说说线程的生命周期和状态?</h3><figure><img src="https://minio.pigx.top/oss/2022/07/zUj8f3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/7VsZS9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。</p><p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#什么是上下文切换" aria-hidden="true">#</a> 什么是上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="什么是线程死锁-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#什么是线程死锁-如何避免死锁" aria-hidden="true">#</a> 什么是线程死锁 ? 如何避免死锁 ?</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>上面的例子符合产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><p>在开发过程中：</p><ol><li><p>要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁</p></li><li><p>要注意加锁时限，可以针对所设置⼀个超时时间</p></li><li><p>要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决</p></li></ol><h3 id="说说-sleep-方法和-wait-方法区别和共同点" tabindex="-1"><a class="header-anchor" href="#说说-sleep-方法和-wait-方法区别和共同点" aria-hidden="true">#</a> 说说 sleep() 方法和 wait() 方法区别和共同点?</h3><ul><li>两者最主要的区别在于：<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h3 id="为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" tabindex="-1"><a class="header-anchor" href="#为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" aria-hidden="true">#</a> 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>new 一个 Thread，线程进入了新建状态。</p><p>调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</p><p><code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h3 id="说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 说一说自己对于 synchronized 关键字的了解?</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><p>另外，在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p><p><strong>为什么呢？</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从<strong>用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="说说自己是怎么使用-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#说说自己是怎么使用-synchronized-关键字" aria-hidden="true">#</a> 说说自己是怎么使用 synchronized 关键字?</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p><p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <em>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</em>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li></ul><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</p><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。</p><p>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="构造方法可以使用-synchronized-关键字修饰么" tabindex="-1"><a class="header-anchor" href="#构造方法可以使用-synchronized-关键字修饰么" aria-hidden="true">#</a> 构造方法可以使用 synchronized 关键字修饰么？</h3><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h3 id="讲一下-synchronized-关键字的底层原理" tabindex="-1"><a class="header-anchor" href="#讲一下-synchronized-关键字的底层原理" aria-hidden="true">#</a> 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h3 id="说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" tabindex="-1"><a class="header-anchor" href="#说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" aria-hidden="true">#</a> 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环， 可以理解为就是啥也不干，防止从用户态转入内核态。</p><p><strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上 的自旋时间和锁的持有者状态来决定。</p><p><strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p><p><strong>锁粗化</strong>：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。</p><p><strong>偏向锁</strong>：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。</p><p><strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用 CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败， 当前线程就尝试自旋来获得锁。</p><p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p><figure><img src="https://minio.pigx.top/oss/2022/07/QwXTUf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="谈谈-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#谈谈-synchronized-和-reentrantlock-的区别" aria-hidden="true">#</a> 谈谈 synchronized 和 ReentrantLock 的区别？</h3><p>两者都是可重入锁。<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。</p><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）。</p><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁 sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识 来标识锁的状态。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h3 id="讲讲cpu-缓存模型" tabindex="-1"><a class="header-anchor" href="#讲讲cpu-缓存模型" aria-hidden="true">#</a> 讲讲CPU 缓存模型？</h3><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p><p><strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p><p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:</p><figure><img src="https://minio.pigx.top/oss/2022/07/uU4fqh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>CPU Cache 的工作方式：</strong></p><p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。</p><p>但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p><p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</strong></p><h3 id="缓存一致性协议" tabindex="-1"><a class="header-anchor" href="#缓存一致性协议" aria-hidden="true">#</a> 缓存一致性协议</h3><p>缓存一致性协议（Cache Coherence Protocol）是用于多处理器系统或多核系统中的共享缓存架构的一种协议，其目的是确保不同处理器（核心）之间对共享数据的访问和更新保持一致。</p><p>在多处理器系统中，每个处理器都有自己的缓存，并且缓存中可能包含相同的共享数据。缓存一致性协议定义了处理器之间如何协调共享数据的读写操作，以避免数据不一致性导致的错误结果。</p><p>常见的缓存一致性协议包括：</p><ol><li><strong>MSI（Modified, Shared, Invalid）协议</strong>：MSI 协议定义了三种状态：Modified（修改状态）、Shared（共享状态）和Invalid（无效状态）。当某个处理器修改了数据时，其他处理器的缓存中的数据会被标记为无效；当数据被多个处理器共享时，数据处于共享状态；当数据被修改但尚未被其他处理器读取时，数据处于修改状态。</li><li><strong>MESI（Modified, Exclusive, Shared, Invalid）协议</strong>：MESI 协议在 MSI 的基础上增加了 Exclusive（独占状态），用于表示某个处理器独占拥有某块数据，不需要与其他处理器进行共享。</li><li><strong>MOESI（Modified, Owned, Exclusive, Shared, Invalid）协议</strong>：MOESI 协议在 MESI 的基础上增加了 Owned（所有权状态），用于表示某块数据虽然处于共享状态，但当前处理器是该数据的所有者。</li></ol><h3 id="讲一下-jmm-java-内存模型" tabindex="-1"><a class="header-anchor" href="#讲一下-jmm-java-内存模型" aria-hidden="true">#</a> 讲一下 JMM(Java 内存模型)？</h3><p>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。</p><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><blockquote><ul><li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li></ul></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/jDlkFc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>所以，<strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/zBKLn7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="并发编程的三个重要特性" tabindex="-1"><a class="header-anchor" href="#并发编程的三个重要特性" aria-hidden="true">#</a> 并发编程的三个重要特性？</h3><ol><li><strong>原子性</strong> : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="说说-synchronized-关键字和-volatile-关键字的区别" tabindex="-1"><a class="header-anchor" href="#说说-synchronized-关键字和-volatile-关键字的区别" aria-hidden="true">#</a> 说说 synchronized 关键字和 volatile 关键字的区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id="为什么要用线程池" tabindex="-1"><a class="header-anchor" href="#为什么要用线程池" aria-hidden="true">#</a> 为什么要用线程池？</h3><p>​ <strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="实现-runnable-接口和-callable-接口的区别" tabindex="-1"><a class="header-anchor" href="#实现-runnable-接口和-callable-接口的区别" aria-hidden="true">#</a> 实现 Runnable 接口和 Callable 接口的区别？</h3><p>​ <strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。</p><h3 id="执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#执行-execute-方法和-submit-方法的区别是什么呢" aria-hidden="true">#</a> 执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="如何创建线程池" tabindex="-1"><a class="header-anchor" href="#如何创建线程池" aria-hidden="true">#</a> 如何创建线程池？</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/EvNPJA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p><p>我们可以创建三种类型的 ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/KYVcpp.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="threadpoolexecutor构造函数重要参数分析" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor构造函数重要参数分析" aria-hidden="true">#</a> ThreadPoolExecutor构造函数重要参数分析？</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。</p><figure><img src="https://minio.pigx.top/oss/2022/07/h5dDkk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="juc-包中的原子类是哪-4-类" tabindex="-1"><a class="header-anchor" href="#juc-包中的原子类是哪-4-类" aria-hidden="true">#</a> JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li></ul><h3 id="能不能给我简单介绍一下-atomicinteger-类的原理" tabindex="-1"><a class="header-anchor" href="#能不能给我简单介绍一下-atomicinteger-类的原理" aria-hidden="true">#</a> 能不能给我简单介绍一下 AtomicInteger 类的原理？</h3><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。</p><p>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h3 id="介绍一下aqs" tabindex="-1"><a class="header-anchor" href="#介绍一下aqs" aria-hidden="true">#</a> 介绍一下AQS?</h3><p>​ AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。</p><ol><li>AQS是⼀个JAVA线程同步的框架。是JDK中很多锁⼯具的核⼼实现框架。</li><li>在AQS中，维护了⼀个信号量state和⼀个线程组成的双向链表队列。其中，这个线程队列，就是⽤来给线程排队的，⽽state就像是⼀个红绿灯，⽤来控制线程排队或者放⾏的。 在不同的场景下， 有不⽤的意义。</li><li>在可重⼊锁这个场景下，state就⽤来表示加锁的次数。0标识⽆锁，每加⼀次锁，state就加1。释 放锁state就减1。</li></ol><h3 id="shutdown-和shutdownnow-的区别" tabindex="-1"><a class="header-anchor" href="#shutdown-和shutdownnow-的区别" aria-hidden="true">#</a> shutdown()和shutdownNow()的区别？</h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isterminated-和isshutdown-的区别" tabindex="-1"><a class="header-anchor" href="#isterminated-和isshutdown-的区别" aria-hidden="true">#</a> isTerminated()和isShutdown()的区别？</h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true。</li></ul><h3 id="说一下线程之间是如何通信的" tabindex="-1"><a class="header-anchor" href="#说一下线程之间是如何通信的" aria-hidden="true">#</a> 说一下线程之间是如何通信的？</h3><p>线程之间的通信有两种方式：共享内存和消息传递。</p><ul><li><p><strong>共享内存</strong></p><pre><code>  在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来 、隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。

线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：
</code></pre></li></ul><ol><li><p>线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</p></li><li><p>线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</p></li></ol><ul><li><p><strong>消息传递</strong></p><pre><code>  在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 wait() 和 notify() ，或者 BlockingQueue 。
</code></pre></li></ul><h3 id="cas的原理以及缺点" tabindex="-1"><a class="header-anchor" href="#cas的原理以及缺点" aria-hidden="true">#</a> CAS的原理以及缺点?</h3><ul><li>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含 三个操作数：</li></ul><ol><li><p>变量内存地址，V表示</p></li><li><p>旧的预期值，A表示</p></li><li><p>准备设置的新值，B表示</p></li></ol><p>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</p><ul><li>CAS的<strong>缺点</strong>主要有3点：</li></ul><ol><li><p><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是 A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是 ABA的问题大部分场景下都不影响并发的最终效果。Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段， 更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p></li><li><p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多 个可以通过AtomicReference来处理或者使用锁synchronized实现。</p></li></ol><p>CompareAndSwap 是一个 native 方法，实际上它最终还是会面临同样的问题， 就是先从内存地址中读取 state 的值，然后去比较，最后再修改。 这个过程不管是在什么层面上实现，都会存在原子性问题。 所以呢， CompareAndSwap 的底层实现中，在多核 CPU 环境下，会增加一个 Lock 指令对缓存或者总线加锁，从而保证比较并替换这两个指令的原子性。 CAS 主要用在并发场景中，比较典型的使用场景有两个。</p><p>第一个是 JUC 里面 Atomic 的原子实现，比如 AtomicInteger，AtomicLong。</p><p>第二个是实现多线程对 共 享 资 源 竞 争 的 互 斥 性 质 ， 比 如 在 AQS 、 ConcurrentHashMap、ConcurrentLinkedQueue 等都有用到。</p><h3 id="引用类型有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#引用类型有哪些-有什么区别" aria-hidden="true">#</a> 引用类型有哪些？有什么区别？</h3><p>引用类型主要分为强软弱虚四种：</p><ol><li><p><strong>强引用</strong>指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。</p></li><li><p><strong>软引用</strong>可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</p></li><li><p><strong>弱引用</strong>可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC 的时候一定会被回收，而不管内存是否足够。</p></li><li><p><strong>虚引用</strong>也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和 ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</p></li></ol><h3 id="happen-before规则" tabindex="-1"><a class="header-anchor" href="#happen-before规则" aria-hidden="true">#</a> happen-before规则？</h3><p>&quot;happen-before&quot; 规则是指在并发编程中用于描述事件发生顺序的一组规则。这些规则帮助确保程序中的并发操作能够按照预期顺序执行，从而避免出现意外的结果。</p><p>。具体来说，如果一个操作 &quot;happens-before&quot; 另一个操作，那么第一个操作的结果对于第二个操作是可见的，即第一个操作的效果将被第二个操作感知到。</p><p>一些常见的 &quot;happen-before&quot; 规则包括：</p><ol><li><strong>程序顺序规则</strong>：在单个线程内，程序按照顺序执行的操作之间存在 happens-before 关系。</li><li><strong>监视器锁规则</strong>：线程解锁一个监视器锁之前，对该监视器锁的所有解锁操作都 happens-before 于随后对同一监视器锁的加锁操作。</li><li><strong>volatile变量规则</strong>：对一个 volatile 变量的写操作 happens-before 后续对该变量的读操作。</li><li><strong>传递性</strong>：如果 A happens-before B，B happens-before C，则可以推导出 A happens-before C。</li></ol><p>通过遵循 &quot;happen-before&quot; 规则，程序员可以更好地控制并发操作之间的顺序性，避免数据竞争和不确定性，确保程序的正确性和可靠性。</p><h3 id="线程的sleep、wait、join、yield如何使用" tabindex="-1"><a class="header-anchor" href="#线程的sleep、wait、join、yield如何使用" aria-hidden="true">#</a> 线程的sleep、wait、join、yield如何使用？</h3><p><strong>sleep</strong>: 让线程睡眠，期间会出让cpu，在同步代码块中，不会释放锁。 <strong>wait</strong>(必须先获得对应的锁才能调用): 让线程进入等待状态,释放当前线程持有的锁资源线程只有在notify 或者notifyAll方法调用后才会被唤醒,然后去争夺锁。 <strong>join</strong>: 线程之间协同方式,使用场景: 线程A必须等待线程B运行完毕后才可以执行,那么就可以在线程A的代码中加入ThreadB.join(); <strong>yield</strong>: 让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p><h3 id="threadlocal的原理是什么-使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#threadlocal的原理是什么-使用场景有哪些" aria-hidden="true">#</a> ThreadLocal的原理是什么，使用场景有哪些？</h3><p>Thread类中有两个变量threadLocals和inheritableThreadLocals，二者都是ThreadLocal内部类ThreadLocalMap类型的变量，我们通过查看内部内ThreadLocalMap可以发现实际上它类似于一个HashMap。key为ThreadLocal实例,value是线程设置的值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>每个线程的本地变量不是存放在ThreadLocal实例中，而是放在调用线程的<strong>ThreadLocals</strong>变量里面。也就是说，<strong>ThreadLocal类型的本地变量是存放在具体的线程空间上</strong>，其本身相当于一个装载本地变量的载体，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量,防止出现<strong>内存泄漏。</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
             m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="threadlocal有哪些内存泄露问题-如何避免" tabindex="-1"><a class="header-anchor" href="#threadlocal有哪些内存泄露问题-如何避免" aria-hidden="true">#</a> ThreadLocal有哪些内存泄露问题，如何避免？</h3><p>每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个<strong>弱引用</strong>，我们知道弱引用有利于GC回收。</p><p>当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系。</p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。</p><p>所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到<strong>线程池</strong>，那就更坑了。 那么要怎么避免这个问题呢？ 在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</p><p>下面再对ThreadLocal进行简单的总结：</p><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要目的视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul><h3 id="volatile的可见性和禁止指令重排序怎么实现的" tabindex="-1"><a class="header-anchor" href="#volatile的可见性和禁止指令重排序怎么实现的" aria-hidden="true">#</a> volatile的可见性和禁止指令重排序怎么实现的？</h3><ul><li><p>可见性： volatile的功能就是被修饰的变量在被修改后可以立即同步到主内存，被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性 写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。</p><p>读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</p></li><li><p>禁止指令重排序： volatile是通过<strong>内存屏障</strong>来禁止指令重排序 JMM内存屏障的策略</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul><h3 id="concurrenthashmap底层原理是什么" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap底层原理是什么" aria-hidden="true">#</a> ConcurrentHashMap底层原理是什么？</h3><p>1.7 数据结构： 内部主要是一个Segment数组，而数组的每一项又是一个HashEntry数组，元素都存在HashEntry数组里。因为每次锁定的是Segment对象，也就是整个HashEntry数组，所以又叫分段锁。 <img src="https://minio.pigx.top/oss/2022/08/ZlhewO.png" alt="" loading="lazy"></p><p>1.8 数据结构： 与HashMap一样采用：数组+链表+红黑树</p><figure><img src="https://minio.pigx.top/oss/2022/08/1OPJA4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>底层原理则是采用锁链表或者红黑树头结点，相比于HashTable的方法锁，力度更细，是对数组（table）中的桶（链表或者红黑树）的头结点进行锁定，这样锁定，只会影响数组（table）当前下标的数据，不会影响其他下标节点的操作，可以提高读写效率。 putVal执行流程：</p><ol><li>判断存储的key、value是否为空，若为空，则抛出异常</li><li>计算key的hash值，随后死循环（该循环可以确保成功插入，当满足适当条件时，会主动终止），判断table表为空或者长度为0，则初始化table表。</li><li>根据hash值获取table中该下标对应的节点，如果该节点为空，则根据参数生成新的节点，并以CAS的方式进行更新，并终止死循环。</li><li>如果该节点的hash值是MOVED(-1)，表示正在扩容，则辅助对该节点进行转移。</li><li>对数组（table）中的节点，即桶的头结点进行锁定，如果该节点的hash大于等于0，表示此桶是链表，然后对该桶进行遍历（死循环），寻找链表中与put的key的hash值相等，并且key相等的元素，然后进行值的替换，如果到链表尾部都没有符合条件的，就新建一个node，然后插入到该桶的尾部，并终止该循环遍历。</li><li>如果该节点的hash小于0，并且节点类型是TreeBin，则走红黑树的插入方式。</li><li>判断是否达到转化红黑树的阈值，如果达到阈值，则链表转化为红黑树。</li></ol><h3 id="线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" tabindex="-1"><a class="header-anchor" href="#线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" aria-hidden="true">#</a> 线程池中阻塞队列的作⽤？为什么是先添加队列⽽不是先创建最⼤线程？</h3><p>1、⼀般的队列只能保证作为⼀个有限⻓度的缓冲区，如果超出了缓冲⻓度，就⽆法保留当前的任务了， 阻塞队列通过阻塞可以保留住当前想要继续⼊队的任务。</p><pre><code>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进⼊wait状态，释放cpu资源。

阻塞队列⾃带阻塞和唤醒的功能，不需要额外处理，⽆任务执⾏时,线程池利⽤阻塞队列的take⽅法挂起，从⽽维持核⼼线程的存活、不⾄于⼀直占⽤cpu资源。
</code></pre><p>2、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</p><p>就好⽐⼀个企业⾥⾯有10个（core）正式⼯的名额，最多招10个正式⼯，要是任务超过正式⼯⼈数 （task &gt; core）的情况下，⼯⼚领导（线程池）不是⾸先扩招⼯⼈，还是这10⼈，但是任务可以稍微积 压⼀下，即先放到队列去（代价低）。10个正式⼯慢慢⼲，迟早会⼲完的，要是任务还在继续增加，超 过正式⼯的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时⼯）要是正式⼯加上外包还 是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p><h3 id="reentrantlock中的公平锁和非公平锁的底层实现" tabindex="-1"><a class="header-anchor" href="#reentrantlock中的公平锁和非公平锁的底层实现" aria-hidden="true">#</a> ReentrantLock中的公平锁和⾮公平锁的底层实现</h3><p>ReentrantLock中的公平锁和⾮公平锁的底层实现</p><p>⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤AQS来进⾏排队，它们的区别在于：线程在使⽤lock()⽅法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队， 则当前线程也进⾏排队，如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。</p><p>不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线程，所以<strong>⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。</strong></p><p>另外，ReentrantLock是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。</p><figure><img src="https://minio.pigx.top/oss/2022/08/aiHXPq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/Gc8pLm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="reentrantlock中trylock-和lock-方法的区别" tabindex="-1"><a class="header-anchor" href="#reentrantlock中trylock-和lock-方法的区别" aria-hidden="true">#</a> ReentrantLock中tryLock()和lock()⽅法的区别</h3><ol><li><p>tryLock()表示尝试加锁，可能加到，也可能加不到，该⽅法不会阻塞线程，如果加到锁则返回 true，没有加到则返回false</p></li><li><p>lock()表示阻塞加锁，线程会阻塞直到加到锁，⽅法也没有返回值</p></li></ol><h3 id="countdownlatch和semaphore的区别和底层原理" tabindex="-1"><a class="header-anchor" href="#countdownlatch和semaphore的区别和底层原理" aria-hidden="true">#</a> CountDownLatch和Semaphore的区别和底层原理</h3><p>CountDownLatch表示计数器，可以给CountDownLatch设置⼀个数字，⼀个线程调⽤ CountDownLatch的await()将会阻塞，其他线程可以调⽤CountDownLatch的countDown()⽅法来对 CountDownLatch中的数字减⼀，当数字被减成0后，所有await的线程都将被唤醒。 对应的底层原理就是，调⽤await()⽅法的线程会利⽤AQS排队，⼀旦数字被减为0，则会将AQS中 排队的线程依次唤醒。</p><p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通过acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过AQS来排队，可以通过release() ⽅法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第⼀个线程开始依次唤醒，直到没有空闲许可。</p><h3 id="线程池如何知道一个线程的任务已经执行完成" tabindex="-1"><a class="header-anchor" href="#线程池如何知道一个线程的任务已经执行完成" aria-hidden="true">#</a> 线程池如何知道一个线程的任务已经执行完成</h3><p>在线程池中，有一个 submit() 方法，它提供了一个 Future 的返回值，我们通过 Future.get() 方法来获得任务的执行结果， 当线程池中的任务没执行完之前，future.get()方法会一直阻塞，直到任务执行结束。因此，只要 future.get() 方法正常 返回，也就意味着传入到线程池中的任务已经执行完成了！</p><p>可以引入一个 CountDownLatch 计数器，它可以通过初始化指定一个计数器进行倒计时，其中有两个方法分别是 await() 阻塞线程，以及 countDown() 进行倒计await()时，一旦倒计时归零，所以被阻塞在方法的线程都会被释放。</p><p>基于这样的原理，我们可以定义一个 CountDownLatch 对象并且计数器为 1，接着在线程池代码块后面调用 await() 方法阻塞主线程，然后，当传入到线程池中的 任务执行完成后，调用 countDown() 方法表示任务执行结束。</p><p>最后，计数器归零 0， 唤醒阻塞在await()方法的线程。</p><figure><img src="https://minio.pigx.top/oss/2022/08/Vby9bY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>基于这个问题，我简单总结一下，不管是线程池内部还是外部，要想知道线程是 否执行结束，我们必须要获取线程执行结束后的状态，而线程本身没有返回值， 所以只能通过阻塞-唤醒的方式来实现，future.get 和 CountDownLatch 都是这样 一个原理。</p><h3 id="wait-和-notify-这个为什么要在-synchronized-代码块中" tabindex="-1"><a class="header-anchor" href="#wait-和-notify-这个为什么要在-synchronized-代码块中" aria-hidden="true">#</a> wait 和 notify 这个为什么要在 synchronized 代码块中？</h3><p>wait 和 notify 用来实现多线程之间的协调， wait 表示让线程进入到阻塞状态， notify 表示让阻塞的线程唤醒。</p><p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p><p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变 量 s，从而完成数据通信。</p><p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修 改过了共享变量 s， 否则就需要等待。</p><p>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。</p><p>所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线 程在什么条件下等待，什么条件下唤醒。</p><figure><img src="https://minio.pigx.top/oss/2022/08/tP2WSv.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享 变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变 量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线 程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之 前的通信。</p><p>所以这也是为什么 wait/notify 需要放在 Synchronized 同步代码块中的原因，有 了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等 待和条件唤醒。</p><p>另外，为了避免 wait/notify 的错误使用， jdk 强制要求把 wait/notify 写在同步代 码块里面，否则会抛出 IllegalMonitorStateException</p><p>最后，基于 wait/notify 的特性，非常适合实现生产者消费者的模型，比如说用 wait/notify 来实现连接池就绪前的等待与就绪后的唤醒。</p><h3 id="java中interrupted-和-isinterruptedd方法的区别" tabindex="-1"><a class="header-anchor" href="#java中interrupted-和-isinterruptedd方法的区别" aria-hidden="true">#</a> Java中interrupted 和 isInterruptedd方法的区别？</h3><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。</p><p>Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。 当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出 InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能 被其它线程调用中断来改变。</p><h3 id="synchronizedmap和concurrenthashmap有什么区别" tabindex="-1"><a class="header-anchor" href="#synchronizedmap和concurrenthashmap有什么区别" aria-hidden="true">#</a> SynchronizedMap和ConcurrentHashMap有什么区别？</h3><p>SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。 而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程 访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。</p><p>所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加 有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行 数据修改，也不会抛出ConcurrentModiﬁcationException。</p><h3 id="线程池核心线程数怎么设置呢" tabindex="-1"><a class="header-anchor" href="#线程池核心线程数怎么设置呢" aria-hidden="true">#</a> 线程池核心线程数怎么设置呢？</h3><p>分为CPU密集型和IO密集型</p><p><strong>CPU</strong></p><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦 任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>IO密集型</strong></p><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用CPU来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们 可以多配置一些线程，具体的计算方法是 ： 核心线程数= CPU核心数量 * 2。</p><h3 id="java线程池中队列常用类型有哪些" tabindex="-1"><a class="header-anchor" href="#java线程池中队列常用类型有哪些" aria-hidden="true">#</a> Java线程池中队列常用类型有哪些？</h3><p>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue</p><p>SynchronousQueue一个不存储元素的阻塞队列。</p><p>PriorityBlockingQueue一个具有优先级的无限阻塞队列。PriorityBlockingQueue也是基于最小二叉堆实现</p><p>DelayQueue 只有当其指定的延迟时间到了，才能够从队列中获取到该元素。 DelayQueue 是一个没有大小限制的队列， 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费 者）才会被阻塞。</p><h3 id="说说cyclicbarrier和countdownlatch的区别" tabindex="-1"><a class="header-anchor" href="#说说cyclicbarrier和countdownlatch的区别" aria-hidden="true">#</a> 说说CyclicBarrier和CountDownLatch的区别？</h3><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><h3 id="线程类的构造方法、静态块是被哪个线程调用的" tabindex="-1"><a class="header-anchor" href="#线程类的构造方法、静态块是被哪个线程调用的" aria-hidden="true">#</a> 线程类的构造⽅法、静态块是被哪个线程调⽤的?</h3><p>线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。</p><h3 id="死锁与活锁的区别-死锁与锁饥饿的区别" tabindex="-1"><a class="header-anchor" href="#死锁与活锁的区别-死锁与锁饥饿的区别" aria-hidden="true">#</a> 死锁与活锁的区别，死锁与锁饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的 现象，若无外力作用，它们都将无法推进下去。</p><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的 实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>锁饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p>Java 中导致锁饥饿的原因：</p><p>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p><p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p><p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p><h3 id="volatile实现可见性的原理" tabindex="-1"><a class="header-anchor" href="#volatile实现可见性的原理" aria-hidden="true">#</a> volatile实现可见性的原理</h3><p>实现原理是内存屏障（MemoryBarrier）,其原理为:当CPU写数据时,如果发现一个变量在其他CPU中存有副本,那么会发出信号量通知其他CPU将该副本对应的缓存行置为无效状态,当其他CPU读取到变量副本的时候,会发现该缓存行是无效的,然后’它会从主存重新读取变量。</p><h3 id="是否可以把一个数组修饰为volatile" tabindex="-1"><a class="header-anchor" href="#是否可以把一个数组修饰为volatile" aria-hidden="true">#</a> 是否可以把一个数组修饰为volatile?</h3><p>在Java中可以用volatile来修饰数组，但是volatile只作用在这个数组的引用上，而不是整个数组的内容。也就是说如果—个线程修改了这个数组的引用,这个修改会对其他所有线程可见。但是如果只是修改了数组的内容，则无法保证这个修改对其他数组可见。</p><h3 id="cpu使用率过高问题排查" tabindex="-1"><a class="header-anchor" href="#cpu使用率过高问题排查" aria-hidden="true">#</a> CPU使用率过高问题排查</h3><ul><li>top命令找到消耗CPU高的进程ID</li><li>top -p {进程ID} 单独监控该进程</li><li>在上一步的监控界面输入H，获取当前进程下的所有线程信息</li><li>找到消耗CPU特别高的线程ID</li><li>执行jstack {进程ID} 输出所有的线程信息</li><li>将线程ID转成16进制</li><li>根据16进制编码在jstack输出的线程信息中找到对应的线程</li><li>解读线程信息，定位具体的代码位置</li></ul><p><strong>CPU使用率一般多少正常</strong></p><p>CPU是整个计算机的核心计算资源，对于一个服务来说，在计算机上的体现是一个进程，一个进程可以开启多个线程，而CPU的最小执行单元是线程。 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p><figure><img src="https://img2022.cnblogs.com/blog/1367382/202205/1367382-20220528104812761-293879759.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因此CPU使用率可以表示某个时间点机器上程序的运行情况。通常CPU使用率在0-75%是正常，如果经常在90%以上，则说明CPU使用率过高，可能有问题存在。</p><p>现在操作系统都是基于多任务分时设计的，也就是机器上运行多个程序，正常情况下，某一个线程执行一定时间之后操作系统就会调度将CPU切换到其他线程，因此CPU使用率过高，最直接的原因可能就是<strong>创建线程过多或者某一个线程对应的程序设计有问题</strong>，导致CPU一直处于调度状态或者一直被某一个线程占用。 最明显的体现就是，计算机开机的时候，如果自启动项过多，就会短时间内CPU使用率飚高，这个时候如果自己再去开启其他应用程序，就会出现无响应或者响应慢的情况。</p><p><strong>2.具体原因</strong></p><p>导致CPU飚高的原因 （1）线程过多 创建线程过多导致CPU上下文切换频繁，对于CPU来说，同一时刻下每个CPU核心只能运行一个线程，如果有多个线程要执行，CPU只能通过上下文切换的方式来执行不同的线程。上下文切换需要做两个事情</p><ul><li>保存当前运行线程的执行状态</li><li>让处于等待状态的线程来执行 这两个过程需要CPU执行内核相关指令实现状态保存到响应的寄存器和存储器，如果较多的上下文切换会频繁的占据CPU而占用资源，无法去执行用户进程中的指令，导致实际的用户进程的响应速度下降。</li></ul><p>（2）代码逻辑问题</p><p>如果线程出现死循环等情况无法退出，也会一直占用CPU资源无法释放，（但是现在一般程序都有抢占式调度？某一个线程占用一定时间CPU或者内存达到某一定阈值就会出现抢占式调度。）</p><p><strong>3.尝试解决方案</strong></p><p>这两个问题导致的CPU利用率较高，通过top命令，定位到CPU利用率比较高的进程，然后shift+h找到CPU比较高的线程，两种情况。</p><ul><li>CPU利用率过高的一直是同一个线程，说明程序存在线程长期没有释放CPU的情况，</li><li>CPU利用率过高的线程ID不断变化，说明线程创建过多</li></ul><p>也可能是定位之后发现线程对应的代码正确，CPU只是在飚高的某些时刻，用户访问量较大，导致资源不够。</p><pre><code>AQS --&gt; Sync --&gt; NonfairAsyc --&gt; FairAsync
加锁：lock --&gt; nonfairAsyc.lock() --&gt; AQS.acquire(1) --&gt; NonfairAsyc.tryAcquire(1) --&gt; Sync.nonfairTryAcquire(1)
	1.CAS尝试获取锁：如果state的值为0，则获取锁成功，并记录排他有锁线程是当前线程(再次尝试获取锁)。
	2.判断当前线程是否是排他有锁线程，如果是则state的值加1。
	3.获取锁失败，则入队。
解锁：

    1. 判断当前线程是否是排他有锁线程，不是则报错。

    2. 对state的值减1，判断减1后的值是否为0，为0则释放锁。

    3. 不为0则释放锁结束。
</code></pre></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/springboot4/edit/main/src/article/offer/03-juc.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 2235602974@qq.com">付绪壮</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-f9138082.js" defer></script>
  </body>
</html>
