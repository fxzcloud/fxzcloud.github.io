<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?87d678935e4b33455c0390543e7a759d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><title>mysql | 冤种说java</title><meta name="description" content="「流水不争先 争的是滔滔不绝」">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-cde8b1ec.css" as="style"><link rel="stylesheet" href="/assets/style-cde8b1ec.css">
    <link rel="modulepreload" href="/assets/app-f9138082.js"><link rel="modulepreload" href="/assets/framework-159025ca.js"><link rel="modulepreload" href="/assets/03-mysql.html-02555211.js"><link rel="modulepreload" href="/assets/03-mysql.html-77e4165f.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="冤种说java"><!----><span class="site-name hide-in-pad">冤种说java</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/source-code/nacos/clusterSync.html" class="nav-link" aria-label="笔记"><span class="font-icon icon iconfont icon-activity" style=""></span>笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/" class="nav-link active" aria-label="博客"><span class="font-icon icon iconfont icon-blog" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/offer/" class="nav-link active" aria-label="八股"><span class="font-icon icon iconfont icon-shell" style=""></span>八股<!----></a></div><div class="nav-item hide-in-mobile"><a href="/me/other.html" class="nav-link" aria-label="其他"><span class="font-icon icon iconfont icon-share" style=""></span>其他<!----></a></div><div class="nav-item hide-in-mobile"><a href="/about.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-alias" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-software" style=""></span><span class="title">nacos</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/nacos/clusterSync.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos集群同步"><!---->nacos集群同步<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/config.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos配置中心"><!---->nacos配置中心<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/discoverAndSubscribe.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务发现和订阅机制"><!---->nacos服务发现和订阅机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/healthCheck.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos健康检查机制"><!---->nacos健康检查机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/nacos/register.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务注册"><!---->nacos服务注册<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-alias" style=""></span><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/spring/LookUp%E3%80%81DependsOn%E3%80%81Lazy.html" class="nav-link sidebar-link sidebar-page" aria-label="spring常见注解"><!---->spring常见注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpingInject.html" class="nav-link sidebar-link sidebar-page" aria-label="spring依赖注入"><!---->spring依赖注入<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Cache.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cache注解驱动"><!---->spring cache注解驱动<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20Event.html" class="nav-link sidebar-link sidebar-page" aria-label="spring event"><!---->spring event<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring%20MVC.html" class="nav-link sidebar-link sidebar-page" aria-label="spring mvc源码分析"><!---->spring mvc源码分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/Spring@Async.html" class="nav-link sidebar-link sidebar-page" aria-label="spring异步@Async"><!---->spring异步@Async<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringAop.html" class="nav-link sidebar-link sidebar-page" aria-label="spring aop"><!---->spring aop<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringBeanLIfeCycle.html" class="nav-link sidebar-link sidebar-page" aria-label="spring bean的生命周期"><!---->spring bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringConfig.html" class="nav-link sidebar-link sidebar-page" aria-label="spring配置文件"><!---->spring配置文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/spring/SpringTransaction.html" class="nav-link sidebar-link sidebar-page" aria-label="spring事务"><!---->spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-template" style=""></span><span class="title">spring boot</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringBoot/config.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot配置加载"><!---->spring boot配置加载<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringBoot/start.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot启动流程"><!---->spring boot启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-module" style=""></span><span class="title">spring cloud</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/source-code/SpringCloudCommon/configRefresh.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 配置动态刷新"><!---->spring cloud 配置动态刷新<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/loadBalancing.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud loadBalanced"><!---->spring cloud loadBalanced<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/registerAndDiscover.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud 服务注册和发现"><!---->spring cloud 服务注册和发现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/source-code/SpringCloudCommon/springCloudOpenFeign.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud openFeign"><!---->spring cloud openFeign<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->mysql</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer">fxz</a></span><span property="author" content="fxz"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-03-17T06:33:43.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 163 分钟</span><meta property="timeRequired" content="PT163M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category6" role>interview</span><meta property="articleSection" content="interview"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#一条-sql-语句在-mysql-内部是如何执行的" class="router-link-active router-link-exact-active toc-link level3">一条 SQL 语句在 MySQL 内部是如何执行的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql-支持哪些存储引擎-默认使用哪个" class="router-link-active router-link-exact-active toc-link level3">MySQL 支持哪些存储引擎？默认使用哪个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql-存储引擎架构了解吗" class="router-link-active router-link-exact-active toc-link level3">MySQL 存储引擎架构了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#myisam-和-innodb-的区别是什么" class="router-link-active router-link-exact-active toc-link level3">MyISAM 和 InnoDB 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql-查询缓存" class="router-link-active router-link-exact-active toc-link level3">MySQL 查询缓存?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#何谓数据库事务" class="router-link-active router-link-exact-active toc-link level3">何谓数据库事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#并发事务带来了哪些问题" class="router-link-active router-link-exact-active toc-link level3">并发事务带来了哪些问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#不可重复读和幻读有什么区别呢" class="router-link-active router-link-exact-active toc-link level3">不可重复读和幻读有什么区别呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#sql-标准定义了哪些事务隔离级别" class="router-link-active router-link-exact-active toc-link level3">SQL 标准定义了哪些事务隔离级别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#解决幻读的方法" class="router-link-active router-link-exact-active toc-link level3">解决幻读的方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql-的隔离级别是基于锁实现的吗" class="router-link-active router-link-exact-active toc-link level3">MySQL 的隔离级别是基于锁实现的吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql-的默认隔离级别是什么" class="router-link-active router-link-exact-active toc-link level3">MySQL 的默认隔离级别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#表级锁和行级锁了解吗-有什么区别" class="router-link-active router-link-exact-active toc-link level3">表级锁和行级锁了解吗？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#共享锁和排他锁呢" class="router-link-active router-link-exact-active toc-link level3">共享锁和排他锁呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#innodb-有哪几类行锁" class="router-link-active router-link-exact-active toc-link level3">InnoDB 有哪几类行锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#当前读和快照读" class="router-link-active router-link-exact-active toc-link level3">当前读和快照读</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#何为索引-有什么作用" class="router-link-active router-link-exact-active toc-link level3">何为索引？有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#索引的优缺点" class="router-link-active router-link-exact-active toc-link level3">索引的优缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#为什么mysql-没有使用hash作为索引的数据结构呢" class="router-link-active router-link-exact-active toc-link level3">为什么MySQL 没有使用Hash作为索引的数据结构呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#b-树-b-树" class="router-link-active router-link-exact-active toc-link level3">B 树&amp; B+树?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#b-树-b-树两者有何异同呢" class="router-link-active router-link-exact-active toc-link level3">B 树&amp; B+树两者有何异同呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#索引类型" class="router-link-active router-link-exact-active toc-link level3">索引类型?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#聚集索引与非聚集索引以及优缺点" class="router-link-active router-link-exact-active toc-link level3">聚集索引与非聚集索引以及优缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#非聚集索引一定回表查询吗-覆盖索引" class="router-link-active router-link-exact-active toc-link level3">非聚集索引一定回表查询吗(覆盖索引)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#覆盖索引" class="router-link-active router-link-exact-active toc-link level3">覆盖索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#联合索引" class="router-link-active router-link-exact-active toc-link level3">联合索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#最左前缀匹配原则" class="router-link-active router-link-exact-active toc-link level3">最左前缀匹配原则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#创建索引的注意事项" class="router-link-active router-link-exact-active toc-link level3">创建索引的注意事项？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#使用索引的一些建议" class="router-link-active router-link-exact-active toc-link level3">使用索引的一些建议？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#redo-log是什么-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">redo log是什么？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#redo-log刷盘时机-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">redo log刷盘时机？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">为什么不直接刷盘修改后的数据，而是刷盘redo log?Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#什么是binlog-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">什么是binlog？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#binlog记录格式-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">binlog记录格式？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#binlog的写入机制-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">binlog的写入机制？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#undo-log-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">undo log？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#sql注入问题" class="router-link-active router-link-exact-active toc-link level3">sql注入问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#数据库的三范式是什么" class="router-link-active router-link-exact-active toc-link level3">数据库的三范式是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#null和空串判断" class="router-link-active router-link-exact-active toc-link level3">NULL和空串判断?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#like走索引吗" class="router-link-active router-link-exact-active toc-link level3">like走索引吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#主键与索引有什么区别" class="router-link-active router-link-exact-active toc-link level3">主键与索引有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#索引不生效的情况" class="router-link-active router-link-exact-active toc-link level3">索引不生效的情况？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mvvc" class="router-link-active router-link-exact-active toc-link level3">MVVC？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#varchar-10-和int-10-代表什么含义" class="router-link-active router-link-exact-active toc-link level3">varchar(10)和int(10)代表什么含义？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#count-在不同引擎的实现方式" class="router-link-active router-link-exact-active toc-link level3">count(*)在不同引擎的实现方式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#锁的类型有哪些呢" class="router-link-active router-link-exact-active toc-link level3">锁的类型有哪些呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#那-acid-靠什么保证的呢" class="router-link-active router-link-exact-active toc-link level3">那 ACID 靠什么保证的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#说说-mysql-主从同步怎么做的吧" class="router-link-active router-link-exact-active toc-link level3">说说 mysql 主从同步怎么做的吧？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#解释mysql外连接、内连接与自连接的区别" class="router-link-active router-link-exact-active toc-link level3">解释MySQL外连接、内连接与自连接的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#sql语言包括哪几部分-每部分都有哪些操作关键字" class="router-link-active router-link-exact-active toc-link level3">SQL语言包括哪几部分？每部分都有哪些操作关键字？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#sql优化手段有哪些" class="router-link-active router-link-exact-active toc-link level3">SQL优化手段有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#简单说一说drop、delete与truncate的区别" class="router-link-active router-link-exact-active toc-link level3">简单说一说drop、delete与truncate的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#大表如何优化" class="router-link-active router-link-exact-active toc-link level3">大表如何优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#可以使用多少列创建索引" class="router-link-active router-link-exact-active toc-link level3">可以使用多少列创建索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql锁的类型有哪些" class="router-link-active router-link-exact-active toc-link level3">mysql锁的类型有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#怎么处理mysql的慢查询" class="router-link-active router-link-exact-active toc-link level3">怎么处理MySQL的慢查询？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql为什么需要主从同步" class="router-link-active router-link-exact-active toc-link level3">mysql为什么需要主从同步？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#innodb是如何实现事务的" class="router-link-active router-link-exact-active toc-link level3">Innodb是如何实现事务的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#b-树和-b-树的理解" class="router-link-active router-link-exact-active toc-link level3">b 树和 b+树的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#for-update的作用和用法" class="router-link-active router-link-exact-active toc-link level3">for update的作用和用法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#如何保证-repeatable-read-级别绝对不产生幻读" class="router-link-active router-link-exact-active toc-link level3">如何保证 REPEATABLE READ 级别绝对不产⽣幻读？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql的update的加锁情况" class="router-link-active router-link-exact-active toc-link level3">mysql的update的加锁情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql的数据存在磁盘上到底长什么样" class="router-link-active router-link-exact-active toc-link level3">MySQL的数据存在磁盘上到底长什么样</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#为什么用了索引-sql查询还是慢" class="router-link-active router-link-exact-active toc-link level3">为什么用了索引，SQL查询还是慢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#什么是三星索引" class="router-link-active router-link-exact-active toc-link level3">什么是三星索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#count-1-和count-哪个效率高" class="router-link-active router-link-exact-active toc-link level3">count(1)和count(*) 哪个效率高？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" class="router-link-active router-link-exact-active toc-link level3">《阿里巴巴JAVA开发手册》里面写超过三张表禁止join 这是为什么？这样的话那sql要怎么写？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#什么是mysql的索引下推" class="router-link-active router-link-exact-active toc-link level3">什么是mysql的索引下推</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql为什么不丢数据-mysql七种日志" class="router-link-active router-link-exact-active toc-link level3">mysql为什么不丢数据(mysql七种日志)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql中的锁" class="router-link-active router-link-exact-active toc-link level3">mysql中的锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/offer/03-mysql.html#mysql日期类型选择" class="router-link-active router-link-exact-active toc-link level3">mysql日期类型选择</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> mysql</h1><h3 id="一条-sql-语句在-mysql-内部是如何执行的" tabindex="-1"><a class="header-anchor" href="#一条-sql-语句在-mysql-内部是如何执行的" aria-hidden="true">#</a> 一条 SQL 语句在 MySQL 内部是如何执行的?</h3><figure><img src="https://minio.pigx.top/oss/2022/07/zi1jXt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/N2LsQR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="mysql-支持哪些存储引擎-默认使用哪个" tabindex="-1"><a class="header-anchor" href="#mysql-支持哪些存储引擎-默认使用哪个" aria-hidden="true">#</a> MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>​ MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h3 id="mysql-存储引擎架构了解吗" tabindex="-1"><a class="header-anchor" href="#mysql-存储引擎架构了解吗" aria-hidden="true">#</a> MySQL 存储引擎架构了解吗？</h3><p>​ MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h3 id="myisam-和-innodb-的区别是什么" tabindex="-1"><a class="header-anchor" href="#myisam-和-innodb-的区别是什么" aria-hidden="true">#</a> MyISAM 和 InnoDB 的区别是什么？</h3><p><strong>1.是否支持行级锁</strong></p><pre><code>	MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
</code></pre><p><strong>2.是否支持事务</strong></p><pre><code>	MyISAM 不提供事务支持。

	InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。
</code></pre><p><strong>3.是否支持外键</strong></p><pre><code>	MyISAM 不支持，而 InnoDB 支持。

	外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！

	阿里的《Java 开发手册》也是明确规定禁止使用外键的。
</code></pre><figure><img src="https://minio.pigx.top/oss/2022/07/y1XOIB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><pre><code>	MyISAM 不支持，而 InnoDB 支持。

	使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。
</code></pre><p><strong>5.是否支持 MVCC</strong></p><pre><code>	MyISAM 不支持，而 InnoDB 支持。
</code></pre><p><strong>6.索引实现不一样。</strong></p><pre><code>	虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

	InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。
</code></pre><h3 id="mysql-查询缓存" tabindex="-1"><a class="header-anchor" href="#mysql-查询缓存" aria-hidden="true">#</a> MySQL 查询缓存?</h3><p>执行查询语句的时候，会先查询缓存。开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。</p><p>不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</p><h3 id="何谓数据库事务" tabindex="-1"><a class="header-anchor" href="#何谓数据库事务" aria-hidden="true">#</a> 何谓数据库事务？</h3><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><h3 id="并发事务带来了哪些问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来了哪些问题" aria-hidden="true">#</a> 并发事务带来了哪些问题?</h3><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。这种情况通常出现在范围查询中。</li></ul><h3 id="不可重复读和幻读有什么区别呢" tabindex="-1"><a class="header-anchor" href="#不可重复读和幻读有什么区别呢" aria-hidden="true">#</a> <strong>不可重复读和幻读有什么区别呢？</strong></h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><ul><li>对于幻读，一般可以通过锁定整个范围或者使用一致性的快照读来解决，例如在数据库中使用Serializable隔离级别或者通过一定的乐观并发控制机制来避免范围查询时的幻读问题。</li><li>对于不可重复读，通常可以通过锁定特定行或者使用事务版本控制（如乐观锁）来解决，并确保事务在读取数据的同时能够防止其他事务对数据进行修改。</li></ul><h3 id="sql-标准定义了哪些事务隔离级别" tabindex="-1"><a class="header-anchor" href="#sql-标准定义了哪些事务隔离级别" aria-hidden="true">#</a> SQL 标准定义了哪些事务隔离级别?</h3><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">READ-UNCOMMITTED</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">READ-COMMITTED</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">REPEATABLE-READ</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><h3 id="解决幻读的方法" tabindex="-1"><a class="header-anchor" href="#解决幻读的方法" aria-hidden="true">#</a> 解决幻读的方法？</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li></ol><h3 id="mysql-的隔离级别是基于锁实现的吗" tabindex="-1"><a class="header-anchor" href="#mysql-的隔离级别是基于锁实现的吗" aria-hidden="true">#</a> MySQL 的隔离级别是基于锁实现的吗?</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p><p>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="mysql-的默认隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#mysql-的默认隔离级别是什么" aria-hidden="true">#</a> MySQL 的默认隔离级别是什么?</h3><p>​ MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><h3 id="表级锁和行级锁了解吗-有什么区别" tabindex="-1"><a class="header-anchor" href="#表级锁和行级锁了解吗-有什么区别" aria-hidden="true">#</a> 表级锁和行级锁了解吗？有什么区别？</h3><pre><code>	MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

	InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。
</code></pre><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h3 id="共享锁和排他锁呢" tabindex="-1"><a class="header-anchor" href="#共享锁和排他锁呢" aria-hidden="true">#</a> 共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">S 锁</th><th style="text-align:left;">X 锁</th></tr></thead><tbody><tr><td style="text-align:left;">S 锁</td><td style="text-align:left;">不冲突</td><td style="text-align:left;">冲突</td></tr><tr><td style="text-align:left;">X 锁</td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td></tr></tbody></table><h3 id="innodb-有哪几类行锁" tabindex="-1"><a class="header-anchor" href="#innodb-有哪几类行锁" aria-hidden="true">#</a> InnoDB 有哪几类行锁？</h3><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：用于锁定某条记录，阻止其他事务对该记录进行修改。当事务需要修改或删除某条记录时，会对该记录加上记录锁，防止其他事务同时修改同一条记录。</li><li><strong>间隙锁（Gap Lock）</strong> ：用于锁定一个范围，但不包括记录本身。当事务需要插入一条新记录时，会对该记录前后的间隙加上间隙锁，防止其他事务插入具有相同索引值的记录。这样可以避免幻读的问题，确保新插入的记录不会影响到其他事务的查询结果。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，是记录锁和间隙锁的结合，它不仅锁定记录本身，还锁定记录之前的间隙，确保其他事务不能插入相同索引值的记录，同时也防止了幻读的问题。</li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li></ul><h3 id="当前读和快照读" tabindex="-1"><a class="header-anchor" href="#当前读和快照读" aria-hidden="true">#</a> 当前读和快照读</h3><p><strong>当前读</strong>（每次都是读到最新的数据）</p><p>Mysql实现当前读是通过共享锁+排他锁+Next-Key Lock实现的。</p><ul><li>每次对行数据进行<strong>读取</strong>的时候，加<strong>共享锁</strong>。此时就不允许修改，但是允许其他事务读取，所以每次都可以读到最新的数据。</li><li>每次对行数据进行<strong>修改</strong>的时候，加<strong>排他锁</strong>，不允许其他事务读取和修改。这种情况下其他事务读取的数据也一定是最新的数据。</li><li>每次对<strong>范围行数据进行读取</strong>的时候，对这个范围加一个<strong>范围共享锁</strong>。</li><li>每次对<strong>范围行数据进行修改</strong>的时候，读这个范围加一个<strong>范围排它锁</strong>。</li><li>基于上述锁机制，实现当前读，确保<strong>每次读取的都是最新的数据</strong>。</li></ul><p><strong>快照读</strong>（根据快照生成的时间，读的不一定是最新的数据） mysql中的快照读是通过<strong>MVCC+undolog</strong>实现的。 快照读，顾名思义，就是读取快照数据，也就是说当某个数据正在被修改的时候，也可以进行读取该数据，保证读写不冲突。 刚刚提到undolog，当我们对记录做了变更操作时，就会产生undo记录，undo记录中存储的是老版数据，当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着undo列找到满足其可见性的记录，这个找满足可见行的记录依赖。就是说每次都是读取undolog中的数据。</p><p><strong>在读未提交隔离级别下，快照是什么时候生成的？</strong></p><p>没有快照，因为不需要，怎么读都读到最新的。不管是否提交</p><p><strong>在读已提交隔离级别下，快照是什么时候生成的？</strong></p><p>SQL语句开始执行的时候。</p><p><strong>在可重复读隔离级别下，快照是什么时候生成的？</strong></p><p>事务开始的时候。</p><p><strong>怎么知道执行的语句是当前读还是快照读</strong>？</p><p><strong>1.在默认隔离级别（可重复读）下，select 语句默认是快照读</strong></p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">select</span> a <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">id</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2.select 语句加锁是当前读</strong></p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code>共享锁
<span class="token keyword">select</span> a <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">id</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token keyword">in</span> <span class="token class-name">share</span> mode<span class="token punctuation">;</span>

<span class="token preprocessor property">#排他锁</span>
<span class="token keyword">select</span> a <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">id</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> update<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.update 语句是当前读</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/12/R0M0Ls.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="何为索引-有什么作用" tabindex="-1"><a class="header-anchor" href="#何为索引-有什么作用" aria-hidden="true">#</a> 何为索引？有什么作用？</h3><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。索引的作用就相当于书的目录。</p><p>索引的原理：就是把⽆序的数据变成有序的查询。</p><h3 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点?</h3><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="为什么mysql-没有使用hash作为索引的数据结构呢" tabindex="-1"><a class="header-anchor" href="#为什么mysql-没有使用hash作为索引的数据结构呢" aria-hidden="true">#</a> 为什么MySQL 没有使用Hash作为索引的数据结构呢？</h3><p><strong>1.Hash 冲突问题</strong>。</p><p><strong>2.Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><h3 id="b-树-b-树" tabindex="-1"><a class="header-anchor" href="#b-树-b-树" aria-hidden="true">#</a> B 树&amp; B+树?</h3><pre><code>	B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。
</code></pre><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><h3 id="b-树-b-树两者有何异同呢" tabindex="-1"><a class="header-anchor" href="#b-树-b-树两者有何异同呢" aria-hidden="true">#</a> B 树&amp; B+树两者有何异同呢？</h3><ul><li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点(双向链表)。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p><pre><code>  在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。
  
  MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
  
  InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。
</code></pre></li></ul><h3 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> 索引类型?</h3><ul><li><p><strong>主键索引(Primary Key)</strong></p><pre><code>  数据表的主键列使用的就是主键索引。
  
  一张数据表有只能有一个主键，并且主键不能为 null，不能重复。
  
  在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。
</code></pre></li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/8HUiNu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p><strong>二级索引(辅助索引)</strong></p><pre><code>  二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
  
  唯一索引，普通索引，前缀索引等索引属于二级索引。
</code></pre></li></ul><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><figure><img src="https://minio.pigx.top/oss/2022/07/aWnMJ1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="聚集索引与非聚集索引以及优缺点" tabindex="-1"><a class="header-anchor" href="#聚集索引与非聚集索引以及优缺点" aria-hidden="true">#</a> 聚集索引与非聚集索引以及优缺点?</h3><ul><li><p>聚集索引</p><pre><code>  聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。
  
  在 MySQL 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
  
  聚集索引的优点:
  		聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。
  
  聚集索引的缺点：
  1. 依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
  2. 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。
</code></pre></li><li><p>非聚集索引</p><pre><code>  非聚集索引即索引结构和数据分开存放的索引。
  
  二级索引属于非聚集索引。
  
  非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。
  
  非聚集索引的优点：
  		更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的
  
  非聚集索引的缺点：
  1. 跟聚集索引一样，非聚集索引也依赖于有序的数据
  2. 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。
</code></pre></li></ul><p>聚集索引和非聚集索引:</p><figure><img src="https://minio.pigx.top/oss/2022/07/su79VT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="非聚集索引一定回表查询吗-覆盖索引" tabindex="-1"><a class="header-anchor" href="#非聚集索引一定回表查询吗-覆盖索引" aria-hidden="true">#</a> 非聚集索引一定回表查询吗(覆盖索引)?</h3><p><strong>非聚集索引不一定回表查询。</strong></p><h3 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引？</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是<strong>主键+列值</strong>。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/2mBGBo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引？</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h3 id="最左前缀匹配原则" tabindex="-1"><a class="header-anchor" href="#最左前缀匹配原则" aria-hidden="true">#</a> 最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p><p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h3 id="创建索引的注意事项" tabindex="-1"><a class="header-anchor" href="#创建索引的注意事项" aria-hidden="true">#</a> 创建索引的注意事项？</h3><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><pre><code>	虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。
</code></pre><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><pre><code>	因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。
</code></pre><p><strong>4.注意避免冗余索引</strong> 。</p><pre><code>	冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。
</code></pre><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><pre><code>	前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引
</code></pre><h3 id="使用索引的一些建议" tabindex="-1"><a class="header-anchor" href="#使用索引的一些建议" aria-hidden="true">#</a> 使用索引的一些建议？</h3><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ul><h3 id="redo-log是什么-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#redo-log是什么-mysql为什么不丢数据" aria-hidden="true">#</a> <a name="mysql-redo-log"></a>redo log是什么？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p><figure><img src="https://minio.pigx.top/oss/2022/07/Xj4vmP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><figure><img src="https://minio.pigx.top/oss/2022/07/qDRWjN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="redo-log刷盘时机-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#redo-log刷盘时机-mysql为什么不丢数据" aria-hidden="true">#</a> redo log刷盘时机？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p><figure><img src="https://minio.pigx.top/oss/2022/07/87fvqr.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/HGFiR7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=0时</strong>，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/tMdLxm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=1</strong>时，只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/gP3lsU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=2时</strong>，只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/kbkKuY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" aria-hidden="true">#</a> 为什么不直接刷盘修改后的数据，而是刷盘redo log?<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，没有必要把完整的数据页刷盘。</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><h3 id="什么是binlog-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#什么是binlog-mysql为什么不丢数据" aria-hidden="true">#</a> 什么是binlog？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><figure><img src="https://minio.pigx.top/oss/2022/07/1yQA7j.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="binlog记录格式-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#binlog记录格式-mysql为什么不丢数据" aria-hidden="true">#</a> binlog记录格式？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p><figure><img src="https://minio.pigx.top/oss/2022/07/MkA1ZE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p><figure><img src="https://minio.pigx.top/oss/2022/07/e4MfiB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p><h3 id="binlog的写入机制-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#binlog的写入机制-mysql为什么不丢数据" aria-hidden="true">#</a> binlog的写入机制？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p><code>binlog</code>日志刷盘流程如下</p><figure><img src="https://minio.pigx.top/oss/2022/07/c03Uor.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="undo-log-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#undo-log-mysql为什么不丢数据" aria-hidden="true">#</a> undo log？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</p><p>如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><h3 id="sql注入问题" tabindex="-1"><a class="header-anchor" href="#sql注入问题" aria-hidden="true">#</a> sql注入问题？</h3><p>原因:用户传入的参数中注入符合sql的语法，从而破坏原有sql结构语意，达到攻击效果。</p><h3 id="数据库的三范式是什么" tabindex="-1"><a class="header-anchor" href="#数据库的三范式是什么" aria-hidden="true">#</a> 数据库的三范式是什么？</h3><p>第一范式：列不可再分</p><p>第二范式：行可以唯一区分，主键约束</p><p>第三范式：表的非主属性不能依赖与 其他表的非主属性 外键约束</p><h3 id="null和空串判断" tabindex="-1"><a class="header-anchor" href="#null和空串判断" aria-hidden="true">#</a> NULL和空串判断?</h3><p>NULL值是没有值,，它不是空串。如果指定&#39;&#39;(两个单引号，其间没有字符)，这在NOT NULL列中是允许 的。空串是一个有效的值，它不是无值。</p><p>判断NULL需要用 IS NULL 或者 IS NOT NULL。</p><h3 id="like走索引吗" tabindex="-1"><a class="header-anchor" href="#like走索引吗" aria-hidden="true">#</a> like走索引吗?</h3><p>Xxx% 走索引， %xxx不走索引。</p><h3 id="主键与索引有什么区别" tabindex="-1"><a class="header-anchor" href="#主键与索引有什么区别" aria-hidden="true">#</a> 主键与索引有什么区别？</h3><p>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</p><p>主键不允许为空值，唯一索引列允许空值；</p><p>一个表只能有一个主键，但是可以有多个唯一索引；</p><p>主键可以被其他表引用为外键，唯一索引列不可以；</p><p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本</p><h3 id="索引不生效的情况" tabindex="-1"><a class="header-anchor" href="#索引不生效的情况" aria-hidden="true">#</a> 索引不生效的情况？</h3><p>使用不等于查询 NULL值</p><p>列参与了数学运算或者函数</p><p>在字符串like时左边是通配符.比如 %xxx</p><p>当mysql分析全表扫描比使用索引快的时候不使用索引.</p><p>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/04/3Vi0M0.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="mvvc" tabindex="-1"><a class="header-anchor" href="#mvvc" aria-hidden="true">#</a> MVVC？</h3><p>MVCC 全称是多版本并发控制系统，是一种用来解决读 - 写冲突的无锁并发控制。</p><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><p>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳 关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操 作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/12/R0M0Ls.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="varchar-10-和int-10-代表什么含义" tabindex="-1"><a class="header-anchor" href="#varchar-10-和int-10-代表什么含义" aria-hidden="true">#</a> varchar(10)和int(10)代表什么含义？</h3><p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度。</p><p>int的10只是代表了展示的长度, 不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示 时按照长度展示。</p><h3 id="count-在不同引擎的实现方式" tabindex="-1"><a class="header-anchor" href="#count-在不同引擎的实现方式" aria-hidden="true">#</a> count(*)在不同引擎的实现方式?</h3><p>MyISAM :把一个表的总行数存在了磁盘上，执行 count(<em>) 的时候会直接返回这个数，效率很高。</em></p><p>InnoDB : 比较麻烦，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p><h3 id="锁的类型有哪些呢" tabindex="-1"><a class="header-anchor" href="#锁的类型有哪些呢" aria-hidden="true">#</a> 锁的类型有哪些呢？</h3><pre><code>	mysql 锁分为共享锁和排他锁，也叫做读锁和写锁。

	读锁是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。

	写锁是排他的，它会阻塞其他的写锁和读锁。

	从颗粒度来区分，可以分为表锁和行锁两种。 表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候会锁表。 行锁又可以分为乐观锁和悲观锁，悲观锁可以通过 for update 实现，乐观锁则通过版本号实现。
</code></pre><h3 id="那-acid-靠什么保证的呢" tabindex="-1"><a class="header-anchor" href="#那-acid-靠什么保证的呢" aria-hidden="true">#</a> 那 ACID 靠什么保证的呢？</h3><p><strong>A</strong> 原子性由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql</p><p><strong>C</strong> 一致性是由其他三大特性保证，程序代码要保证业务上的一致性</p><p><strong>I</strong> 隔离性由 MVCC 来保证</p><p><strong>D</strong> 持久性由内存 + redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，事务提交的 时候通过 redo log 刷盘，宕机的时候可以从 redo log 恢复</p><h3 id="说说-mysql-主从同步怎么做的吧" tabindex="-1"><a class="header-anchor" href="#说说-mysql-主从同步怎么做的吧" aria-hidden="true">#</a> 说说 mysql 主从同步怎么做的吧？</h3><p>首先先了解 mysql 主从同步的原理</p><ol><li><p>master 提交完事务后，写入 binlog</p></li><li><p>slave 连接到 master，获取 binlog</p></li><li><p>master 创建 dump 线程，推送 binglog 到 slave</p></li><li><p>slave 启动一个 IO 线程读取同步过来的 master 的 binlog，记录到 relay log 中继日志中</p></li><li><p>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步</p></li><li><p>slave 记录自己的 binglog</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/0WPBBl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会 产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此 产生两个概念。</p><p><strong>全同步复制</strong></p><p>主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方 式的话性能会受到严重影响。</p><p><strong>半同步复制</strong></p><p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回 ACK 确认给主库，主库收到至 少一个从库的确认就认为写操作完成。</p><h3 id="解释mysql外连接、内连接与自连接的区别" tabindex="-1"><a class="header-anchor" href="#解释mysql外连接、内连接与自连接的区别" aria-hidden="true">#</a> 解释MySQL外连接、内连接与自连接的区别？</h3><p>先说什么是交叉连接: 交叉连接又叫<strong>笛卡尔积</strong>，它是指不使用任何条件，直接将一个表的所有记录和另一 个表中的所有记录一一匹配。</p><p><strong>内连接</strong> 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在 结果集中，即内连接只连接匹配的行。</p><p><strong>外连接</strong> 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p><p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没 有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。</p><p>右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连 接。</p><h3 id="sql语言包括哪几部分-每部分都有哪些操作关键字" tabindex="-1"><a class="header-anchor" href="#sql语言包括哪几部分-每部分都有哪些操作关键字" aria-hidden="true">#</a> SQL语言包括哪几部分？每部分都有哪些操作关键字？</h3><p>SQL语言包括数据定义(<strong>DDL</strong>)、数据操纵(<strong>DML</strong>),数据控制(<strong>DCL</strong>)和数据查询（<strong>DQL</strong>）四个部分。</p><p>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等</p><p>数据操纵：Select ,insert,update,delete,</p><p>数据控制：grant,revoke</p><p>数据查询：select</p><h3 id="sql优化手段有哪些" tabindex="-1"><a class="header-anchor" href="#sql优化手段有哪些" aria-hidden="true">#</a> SQL优化手段有哪些？</h3><p>1、查询语句中不要使用select * (无法覆盖索引)</p><p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p><p>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</p><p>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时， union all会更好)</p><p>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表 扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有 null值，然后这样查询： select id from t where num=0</p><h3 id="简单说一说drop、delete与truncate的区别" tabindex="-1"><a class="header-anchor" href="#简单说一说drop、delete与truncate的区别" aria-hidden="true">#</a> 简单说一说drop、delete与truncate的区别？</h3><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p><p>delete和truncate只删除表的数据不删除表的结构 速度,</p><p>一般来说: drop&gt; truncate &gt;delete</p><p>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</p><p>truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚.</p><p>TRUNCATE 操作会重置自增长计数器等，相比 DELETE 更为高效。</p><h3 id="大表如何优化" tabindex="-1"><a class="header-anchor" href="#大表如何优化" aria-hidden="true">#</a> 大表如何优化？</h3><ol><li><strong>限定数据的范围</strong></li></ol><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们 可以控制在一个月的范围内；</p><ol start="2"><li><strong>读/写分离</strong></li></ol><p>经典的数据库拆分方案，主库负责写，从库负责读；</p><ol start="3"><li><strong>垂直分区</strong></li></ol><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信 息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>垂直拆分的优点： 可以使得列数据变小， 简化表的结构，易于维护。</p><p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层 进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><ol start="4"><li><strong>水平分区</strong></li></ol><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达 到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据 拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单 一表数据量过大对性能造成影响。</p><p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平 拆分最好分库 。</p><p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能 较差，逻辑复杂。</p><p>下面补充一下数据库分片的两种常见方案：</p><p>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网 的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</p><p>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现 在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p><h3 id="可以使用多少列创建索引" tabindex="-1"><a class="header-anchor" href="#可以使用多少列创建索引" aria-hidden="true">#</a> 可以使用多少列创建索引？</h3><p>任何标准表最多可以创建 16 个索引列。</p><h3 id="mysql锁的类型有哪些" tabindex="-1"><a class="header-anchor" href="#mysql锁的类型有哪些" aria-hidden="true">#</a> mysql锁的类型有哪些？</h3><p>基于锁的属性分类：共享锁、排他锁。</p><p>基于锁的粒度分类：行级锁（innodb ）、表级锁（ innodb 、myisam）、页级锁（ innodb引擎）、记录锁、间隙锁、临键锁。</p><p>基于锁的状态分类：意向共享锁、意向排它锁。</p><p>共享锁（share lock）： 共享锁又称读锁，简称 S 锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p><p>排他锁（exclusive lock）：排他锁又称写锁，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读的问题。</p><p>表锁（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；特点：粒度大，加锁简单，容易冲突；</p><p>行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高</p><p>记录锁（Record lock）:记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录，加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题</p><p>页锁：页级锁是 MysQL 中锁定粒度介于行级锁和表级锁中间的一种锁．表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>间隙锁：是属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读）的事务级别中。</p><p>临键锁（Next-Key lock)：也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p><h3 id="怎么处理mysql的慢查询" tabindex="-1"><a class="header-anchor" href="#怎么处理mysql的慢查询" aria-hidden="true">#</a> 怎么处理MySQL的慢查询？</h3><p>1、开启慢查询日志，准确定位到哪个sql语句出现了问题。</p><p>2、分析sql语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p><p>3、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p><p>4、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p><h3 id="mysql为什么需要主从同步" tabindex="-1"><a class="header-anchor" href="#mysql为什么需要主从同步" aria-hidden="true">#</a> mysql为什么需要主从同步？</h3><p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p><h3 id="innodb是如何实现事务的" tabindex="-1"><a class="header-anchor" href="#innodb是如何实现事务的" aria-hidden="true">#</a> Innodb是如何实现事务的</h3><p>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：</p><ol><li><p>Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中</p></li><li><p>执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据</p></li><li><p>针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中</p></li><li><p>针对update语句⽣成undolog⽇志，⽤于事务回滚</p></li><li><p>如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数据⻚持久化到磁盘中</p></li><li><p>如果事务回滚，则利⽤undolog⽇志进⾏回滚</p></li></ol><h3 id="b-树和-b-树的理解" tabindex="-1"><a class="header-anchor" href="#b-树和-b-树的理解" aria-hidden="true">#</a> b 树和 b+树的理解</h3><p>二叉树，每个节点支持两个分支的树结构，相比于单向链表，多了一个分支。</p><p>二叉查找树，在二叉树的基础上增加了一个规则，左子树的所有节点的值都小于它的根节点，右子树的所有子节点都大于它的根节点。</p><figure><img src="https://minio.pigx.top/oss/2022/08/yUVMQu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>二叉查找树会出现斜树问题，导致时间复杂度增加，因此又引入了一种平衡二叉树，它具有二叉查找树的所有特点，同时增加了一个规则：”它的左右两个子 树的高度差的绝对值不超过 1“。平衡二叉树会采用左旋、右旋的方式来实现平 衡。</p><figure><img src="https://minio.pigx.top/oss/2022/08/fIbPve.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而 B 树是一种多路平衡查找树，它满足平衡二叉树的规则，但是它可以有多 个子树，子树的数量取决于关键字的数量，比如这个图中根节点有两个关键字 3 和 5，那么它能够拥有的子路数量=关键字数+1。</p><p>因此从这个特征来看，在存储同样数据量的情况下，平衡二叉树的高度要大于 B 树。</p><figure><img src="https://minio.pigx.top/oss/2022/08/vorQ5u.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B+树，其实是在 B 树的基础上做的增强，最大的区别有两个：</p><p>B 树的数据存储在每个节点上，而 B+树中的数据是存储在叶子节点，并且通过 链表的方式把叶子节点中的数据进行连接。</p><p>B+树的子路数量等于关键字数</p><p>（如图所示）这个是 B 树的存储结构，从 B 树上可以看到每个节点会存储数据。</p><figure><img src="https://minio.pigx.top/oss/2022/08/GqiEPV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（如图所示）这个是 B+树，B+树的所有数据是存储在叶子节点，并且叶子节点 的数据是用双向链表关联的。</p><figure><img src="https://minio.pigx.top/oss/2022/08/vQXOSH.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B 树和 B+树，一般都是应用在文件系统和数据库系统中，用来减少磁盘 IO 带来 的性能损耗。</p><p>以 Mysql 中的 InnoDB 为例，当我们通过select语句去查询一条数据时，InnoDB需要从磁盘上去读取数据，这个过程会涉及到磁盘 IO 以及磁盘的随机 IO（如图 所示）</p><p>我们知道磁盘 IO 的性能是特别低的，特别是随机磁盘 IO。</p><p>很明显，磁盘 IO 这个过程的性能开销是非常大的，特别是查询的数据量比较多 的情况下。</p><p>所以在 InnoDB 中，干脆对存储在磁盘块上的数据建立一个索引，然后把索引数 据以及索引列对应的磁盘地址，以 B+树的方式来存储。</p><p>如图所示，当我们需要查询目标数据的时候，根据索引从 B+树中查找目标数据 即可，由于 B+树分路较多， 所以只需要较少次数的磁盘 IO 就能查找到。</p><p><strong>为什么用 B 树或者 B+树来做索引结构？</strong></p><p>原因是 AVL（平衡二叉树） 树的高度要比 B 树的高度 要高，而高度就意味着磁盘 IO 的数量。所以为了减少磁盘 IO 的次数，文件系 统或者数据库才会采用 B 树或者 B+树。</p><p><a href="https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="for-update的作用和用法" tabindex="-1"><a class="header-anchor" href="#for-update的作用和用法" aria-hidden="true">#</a> for update的作用和用法？</h3><p><strong>一、for update定义</strong></p><p>for update是一种<strong>行级锁，又叫排它锁</strong>，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。</p><p>只有当出现如下之一的条件，才会释放共享更新锁： 1、执行提交（COMMIT）语句 2、退出数据库（LOG　OFF） 3、程序停止运行</p><p><strong>2、概念和用法</strong></p><p>通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。</p><p>而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键，会锁行数据，如果没有，会锁表。</p><p>由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。</p><p>举个例子: 假设有张表user ，里面有 id 和 name 两列，id是主键。</p><p>例1: (明确指定主键，并且数据真实存在，row lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id=3 FOR UPDATE;

SELECT * FROM user WHERE id=3 and name=&#39;Tom&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例2: (明确指定主键，但数据不存在，无lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id=0 FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例3: (主键不明确，table lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id&lt;&gt;3 FOR UPDATE;

SELECT * FROM user WHERE id LIKE &#39;%3%&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例4: (无主键，table lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE name=&#39;Tom&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意： 1、FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。</p><p>2、要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。</p><p>3、Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。</p><p><strong>3、什么时候需要使用for update？</strong></p><p>借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。</p><p>场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。</p><p><strong>4、for update悲观锁</strong></p><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><h3 id="如何保证-repeatable-read-级别绝对不产生幻读" tabindex="-1"><a class="header-anchor" href="#如何保证-repeatable-read-级别绝对不产生幻读" aria-hidden="true">#</a> 如何保证 REPEATABLE READ 级别绝对不产⽣幻读？</h3><p>在SQL中加⼊ for update (排他锁) 或 lock in share mode (共享锁)语句实现。就是锁住了可能造成幻读的数据，阻⽌数据的写⼊操作。</p><h3 id="mysql的update的加锁情况" tabindex="-1"><a class="header-anchor" href="#mysql的update的加锁情况" aria-hidden="true">#</a> mysql的update的加锁情况</h3><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。 <strong>1.使用了唯一索引</strong> 在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。 <strong>2.没有使用索引</strong> 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。</p><h3 id="mysql的数据存在磁盘上到底长什么样" tabindex="-1"><a class="header-anchor" href="#mysql的数据存在磁盘上到底长什么样" aria-hidden="true">#</a> MySQL的数据存在磁盘上到底长什么样</h3><p><strong>MyISAM</strong></p><p>每个 <code>MyISAM</code> 表都以3个文件存储在磁盘上。这些文件的名称以表名开头，以扩展名指示文件类型。</p><p><code>.frm</code> 文件（frame）存储表<strong>结构</strong>；</p><p><code>.MYD</code> 文件（MY Data）存储表<strong>数据</strong>；</p><p><code>.MYI</code> 文件（MY Index）存储表<strong>索引</strong>。</p><p><code>MySQL</code> 里的数据默认是存放在安装目录下的 data 文件夹中，也可以自己修改。</p><p><code>.MYI</code> 文件组织索引的方式就是 <code>B+tree</code>。叶子节点的 value 处存放的就是<strong>索引所在行的磁盘文件地址</strong>。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/uPOiXS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>底层查找过程</strong>：</p><p>首先会判断查找条件 <code>where</code> 中的字段是否是索引字段，如果是就会先拿着这字段去 <code>.MYI</code> 文件里通过 <code>B+tree</code> 快速定位，从根节点开始定位查找；</p><p>找到后再把这个索引关键字（就是我们的条件）存放的磁盘文件地址拿到 <code>.MYD</code> 文件里面找，从而定位到索引所在行的记录。</p><blockquote><p>表逻辑上相邻的记录行数据在磁盘上并不一定是物理相邻的。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/vLPYia.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>InnoDB</strong></p><p>一张 <code>InnoDB</code> 表底层会对应<strong>2个</strong>文件在文件夹中进行数据存储。</p><p><code>.frm</code> 文件（frame）存储表<strong>结构</strong>；</p><p><code>.ibd</code> 文件（InnoDB Data）存储表<strong>索引+数据</strong>。</p><p>很显然，<code>InnoDB</code> 把索引和数据都放在一个文件里存着了。毫无疑问，<code>InnoDB</code> 表里面的数据也是用 <code>B+tree</code> 数据结构组织起来的。</p><p>下面我们来看看它具体是怎么存储的。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/VWjGsw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>.ibd</code> 存储数据的特点就是 <code>B+tree</code> 的叶子节点上<strong>包括了我们要的索引和该索引所在行的其它列数据</strong>。</p><p><strong>底层查找过程</strong>：</p><p>首先会判断查找条件 <code>where</code> 中的字段是否是索引字段，如果是就会先拿着这字段去 <code>.ibd</code> 文件里通过 <code>B+tree</code> 快速定位，从根节点开始定位查找；</p><p>找到后直接把这个索引关键字及其记录所在行的其它列数据返回。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/HSUnHG.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="为什么用了索引-sql查询还是慢" tabindex="-1"><a class="header-anchor" href="#为什么用了索引-sql查询还是慢" aria-hidden="true">#</a> 为什么用了索引，SQL查询还是慢？</h3><p>慢查询归纳起来大概有这么几种情况：</p><ul><li>全表扫描</li><li>全索引扫描</li><li>索引过滤性不好</li><li>频繁回表的开销</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/10/4lRMDG.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="什么是三星索引" tabindex="-1"><a class="header-anchor" href="#什么是三星索引" aria-hidden="true">#</a> 什么是三星索引？</h3><ol><li><strong>第一颗星 - 使用合适的索引</strong>：确保在<code>WHERE</code>子句中的查询列构成了合适的单列索引或联合索引，以加速数据检索。这是为了减小数据查找的开销，提高查询性能。</li><li><strong>第二颗星 - 避免排序</strong>：当查询中涉及<code>ORDER BY</code>子句时，如果查询结果已经按所需列排序，就可以避免生成临时表或执行排序操作，从而提高查询效率。</li><li><strong>第三颗星 - 覆盖索引</strong>：选择在<code>SELECT</code>中包含尽可能多的索引列，以避免回表查询。回表查询是指在索引中找到匹配行后，还需要进一步检索主表中的数据。通过选择索引列，可以减少回表查询的需求，从而提高查询性能。</li></ol><h3 id="count-1-和count-哪个效率高" tabindex="-1"><a class="header-anchor" href="#count-1-和count-哪个效率高" aria-hidden="true">#</a> count(1)和count(*) 哪个效率高？</h3><p><strong>count(1)和count(列名)对比</strong></p><p>两者的主要区别是：</p><ul><li><code>count(1)</code> 会统计表中的所有的记录数，包含字段为 <code>null</code> 的记录。</li><li><code>count(字段)</code> 会统计该字段在表中出现的次数，忽略字段为 <code>null</code> 的情况。即不统计字段为 <code>null</code> 的记录。</li></ul><hr><p><strong>count(*)、count(1)和count(列名)区别</strong></p><p><strong>执行效果上：</strong></p><ul><li><code>count(*)</code>包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li><code>count(1)</code>包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li><code>count(列名)</code>只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p><strong>执行效率上：</strong></p><ul><li>列名为主键， <code>count(列名)</code> 会比 <code>count(1)</code>快</li><li>列名不为主键， <code>count(1)</code> 会比 <code>count(列名)</code>快</li><li>如果表多个列并且没有主键，则 <code>count(1)</code> 的执行效率优于 <code>count(*)</code></li><li>如果有主键，则 <code>select count(主键)</code> 的执行效率是最优的</li><li>如果表只有一个字段，则 <code>select count（*）</code>最优。</li></ul><h3 id="《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" tabindex="-1"><a class="header-anchor" href="#《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" aria-hidden="true">#</a> 《阿里巴巴JAVA开发手册》里面写超过三张表禁止join 这是为什么？这样的话那sql要怎么写？</h3><p>做这个限制有两个原因</p><p>：一是优化器很弱，涉及多个表的查询，往往得不到很好的查询计划；</p><p>二是<a href="https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">执行器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>很弱，只有nested loop join，block nested loop join和index nested loop join。</p><ol><li><p>nested loop join就是分别从两个表读一行数据进行两两对比，<a href="https://www.zhihu.com/search?q=%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">复杂度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是n^2</p></li><li><p>block nested loop join是分别从两个表读很多行数据，然后进行两两对比，复杂度也是n^2，只是少了些<a href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">函数调用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>等overhead</p></li><li><p>index nested loop join是从第一个表读一行，然后在第二个表的索引中查找这个数据，索引是B+树索引，复杂度可以近似认为是<a href="https://www.zhihu.com/search?q=nlogn&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">nlogn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，比上面两个好很多，<strong>这就是要保证关联字段有索引的原因</strong></p></li><li><p>如果有hash join，就不用做这种限制了，用第一个表（小表）建hash table，第二个表在[hash table](<a href="https://www.zhihu.com/search?q=hash" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?q=hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> table&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A153450286})中查找匹配的项，复杂度是n。缺点是hash table占的内存可能会比较大，不过也有基于磁盘的[hash join](<a href="https://www.zhihu.com/search?q=hash" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?q=hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> join&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A153450286})，实现起来比较复杂</p></li></ol><p><strong>二：在这种限制下SQL怎么写？</strong></p><p>可是我确实需要两个表里的数据链接在一起啊，我们可以做个<a href="https://www.zhihu.com/search?q=%E5%86%97%E4%BD%99&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">冗余<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，建表的时候，就把这些列放在一个表里，比如一开始有student(id, name)，class(id, description)，student_class(student_id, class_id)三张表，这样是符合数据库范式的(第一范式，第二范式，<a href="https://www.zhihu.com/search?q=%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">第三范式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，BC范式等)，没有任何冗余，但是马上就不符合“编程规范“了，那我们可以用一张大表代替它，<a href="https://www.zhihu.com/search?q=student_class_full&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">student_class_full<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>(student_id, class_id, name, description)，这样name和<a href="https://www.zhihu.com/search?q=description&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">description<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>可能要被存储多份，但是由于不需要join了，查询的性能就可以提高很多了。</p><p>任何的<a href="https://www.zhihu.com/search?q=%E8%A7%84%E8%8C%83&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">规范<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>都是在特定情况下的某种妥协，脱离了这个环境，就不一定成立了。</p><h3 id="什么是mysql的索引下推" tabindex="-1"><a class="header-anchor" href="#什么是mysql的索引下推" aria-hidden="true">#</a> 什么是mysql的索引下推</h3><p>MySQL的索引下推（Index Condition Pushdown）是一种查询优化技术，它允许数据库在执行查询时使用索引来过滤不满足条件的行，而不必读取整个数据行，从而提高查询性能。</p><p>具体来说，索引下推的工作方式如下：</p><ol><li><p>当执行一个查询时，MySQL会首先使用索引来查找满足查询条件的行。</p></li><li><p>然后，MySQL会对使用索引定位到的行应用查询中的额外过滤条件。这些额外的条件可以是与索引列无关的其他列的条件。</p></li><li><p>如果行满足额外的过滤条件，它将被包括在查询结果中，否则将被丢弃。</p></li></ol><p>索引下推的优势在于它减少了磁盘和内存的读取操作，因为不需要读取整个数据行，而只需读取索引和满足额外条件的行。这降低了查询的I/O开销，提高了查询性能。</p><h3 id="mysql为什么不丢数据-mysql七种日志" tabindex="-1"><a class="header-anchor" href="#mysql为什么不丢数据-mysql七种日志" aria-hidden="true">#</a> <a name="mysql-logs"></a>mysql为什么不丢数据(mysql七种日志)</h3><p><strong>Mysql逻辑架构</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/ZblHgP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL的逻辑架构大致可以分为三层：</p><ul><li>第一层：处理客户端连接、授权认证，安全校验等。</li><li>第二层：服务器<code>server</code>层，负责对SQL解释、分析、优化、执行操作引擎等。</li><li>第三层：存储引擎，负责MySQL中数据的存储和提取。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/5jIwam.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>redo log（重做日志）</strong><a href="#mysql-redo-log">什么是redo log以及redo log刷盘策略</a></p><p><code>redo log</code>属于MySQL存储引擎<code>InnoDB</code>的事务日志。</p><p>MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存<code>Buffer Pool</code>。这个缓存中包含了磁盘中<strong>部分</strong>数据页（<code>page</code>）的映射，以此来缓解数据库的磁盘压力。</p><p>当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为<strong>脏页</strong>，<code>Buffer Pool</code>中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为<strong>刷脏页</strong>。</p><p><strong>MySQL宕机</strong></p><p>如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时<code>Buffer Pool</code>中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。</p><p>为了解决这个问题引入了<code>redo log</code>，redo Log如其名侧重于重做！它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。</p><p><code>redo log</code>用到了<code>WAL</code>（Write-Ahead Logging）技术，这个技术的核心就在于修改记录前，一定要先写日志，并保证日志先落盘，才能算事务提交完成。</p><p>有了redo log再修改数据时，InnoDB引擎会把更新记录先写在redo log中，在修改<code>Buffer Pool</code>中的数据，当提交事务时，调用<code>fsync</code>把redo log刷入磁盘。至于缓存中更新的数据文件何时刷入磁盘，则由后台线程异步处理。</p><blockquote><p><strong>注意</strong>：此时redo log的事务状态是<code>prepare</code>，还未真正提交成功，要等<code>bin log</code>日志写入磁盘完成才会变更为<code>commit</code>，事务才算真正提交完成。</p></blockquote><p>这样一来即使刷脏页之前MySQL意外宕机也没关系，只要在重启时解析redo log中的更改记录进行重放，重新刷盘即可。</p><p><strong>大小固定</strong></p><p>redo log采用固定大小，循环写入的格式，当redo log写满之后，重新从头开始如此循环写，形成一个环状。</p><p>那为什么要如此设计呢？</p><p>因为redo log记录的是数据页上的修改，如果<code>Buffer Pool</code>中数据页已经刷磁盘后，那这些记录就失效了，新日志会将这些失效的记录进行覆盖擦除。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/nfnqJ3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图中的<code>write pos</code>表示redo log当前记录的日志序列号<code>LSN</code>(log sequence number)，写入还未刷盘，循环往后递增；<code>check point</code>表示redo log中的修改记录已刷入磁盘后的LSN，循环往后递增，这个LSN之前的数据已经全落盘。</p><p><code>write pos</code>到<code>check point</code>之间的部分是redo log空余的部分（绿色），用来记录新的日志；<code>check point</code>到<code>write pos</code>之间是redo log已经记录的数据页修改数据，此时数据页还未刷回磁盘的部分。当<code>write pos</code>追上<code>check point</code>时，会先推动<code>check point</code>向前移动，空出位置（刷盘）再记录新的日志。</p><blockquote><p><strong>注意</strong>：redo log日志满了，在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了。擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求的，此刻MySQL的性能会下降。所以在并发量大的情况下，合理调整redo log的文件大小非常重要。</p></blockquote><p><strong>crash-safe</strong></p><p>因为redo log的存在使得<code>Innodb</code>引擎具有了<code>crash-safe</code>的能力，即MySQL宕机重启，系统会自动去检查redo log，将修改还未写入磁盘的数据从redo log恢复到MySQL中。</p><p>MySQL启动时，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。会先检查数据页中的<code>LSN</code>，如果这个 LSN 小于 redo log 中的LSN，即<code>write pos</code>位置，说明在<code>redo log</code>上记录着数据页上尚未完成的操作，接着就会从最近的一个<code>check point</code>出发，开始同步数据。</p><p>简单理解，比如：redo log的<code>LSN</code>是500，数据页的<code>LSN</code>是300，表明重启前有部分数据未完全刷入到磁盘中，那么系统则将redo log中<code>LSN</code>序号300到500的记录进行重放刷盘。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/UkEzaU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>undo log（回滚日志）</strong></p><p><code>undo log</code>也是属于MySQL存储引擎InnoDB的事务日志。</p><p><code>undo log</code>属于逻辑日志，如其名主要起到回滚的作用，它是保证事务原子性的关键。记录的是数据修改前的状态，在数据修改的流程中，同时会记录一条与当前操作相反的逻辑日志到<code>undo log</code>中。</p><p>我们举个栗子：假如更新ID=1记录的name字段，name原始数据为小富，现改name为程序员内点事</p><p>事务执行<code>update X set name = 程序员内点事 where id =1</code>语句时，先会在<code>undo log</code>中记录一条相反逻辑的<code>update X set name = 小富 where id =1</code>记录，这样当某些原因导致服务异常事务失败，就可以借助<code>undo log</code>将数据回滚到事务执行前的状态，保证事务的完整性。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/h4sKvE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那可能有人会问：同一个事物内的一条记录被多次修改，那是不是每次都要把数据修改前的状态都写入<code>undo log</code>呢？</p><p>答案是不会的！</p><p><code>undo log</code>只负责记录事务开始前要修改数据的原始版本，当我们再次对这行数据进行修改，所产生的修改记录会写入到<code>redo log</code>，<code>undo log</code>负责完成回滚，<code>redo log</code>负责完成前滚。</p><p><strong>回滚</strong></p><p>未提交的事务，即事务未执行<code>commit</code>。但该事务内修改的脏页中，可能有一部分脏块已经刷盘。如果此时数据库实例宕机重启，就需要用回滚来将先前那部分已经刷盘的脏块从磁盘上撤销。</p><p><strong>前滚</strong></p><p>未完全提交的事务，即事务已经执行<code>commit</code>，但该事务内修改的脏页中只有一部分数据被刷盘，另外一部分还在<code>buffer pool</code>缓存上，如果此时数据库实例宕机重启，就需要用前滚来完成未完全提交的事务。将先前那部分由于宕机在内存上的未来得及刷盘数据，从<code>redo log</code>中恢复出来并刷入磁盘。</p><blockquote><p>数据库实例恢复时，先做前滚，后做回滚。</p></blockquote><p>如果你仔细看过了上边的 <code>MySQL数据更新流程图</code> 就会发现，<code>undo log</code>、<code>redo log</code>、<code>bin log</code>三种日志都是在刷脏页之前就已经刷到磁盘了的，相互协作最大限度保证了用户提交的数据不丢失。</p><p><strong>bin log（归档日志）</strong></p><p><code>bin log</code>是一种数据库Server层（和什么引擎无关），以二进制形式存储在磁盘中的逻辑日志。<code>bin log</code>记录了数据库所有<code>DDL</code>和<code>DML</code>操作（不包含 <code>SELECT</code> 和 <code>SHOW</code>等命令，因为这类操作对数据本身并没有修改）。</p><p>默认情况下，二进制日志功能是关闭的。可以通过以下命令查看二进制日志是否开启：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;log_bin&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | OFF   |
+---------------+-------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>也被叫做<code>归档日志</code>，因为它不会像<code>redo log</code>那样循环写擦除之前的记录，而是会一直记录日志。一个<code>bin log</code>日志文件默认最大容量<code>1G</code>（也可以通过<code>max_binlog_size</code>参数修改），单个日志超过最大值，则会新创建一个文件继续写。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show binary logs;
+-----------------+-----------+
| Log_name        | File_size |
+-----------------+-----------+
| mysq-bin.000001 |      8687 |
| mysq-bin.000002 |      1445 |
| mysq-bin.000003 |      3966 |
| mysq-bin.000004 |       177 |
| mysq-bin.000005 |      6405 |
| mysq-bin.000006 |       177 |
| mysq-bin.000007 |       154 |
| mysq-bin.000008 |       154 |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>日志的内容格式其实就是执行SQL命令的反向逻辑，这点和<code>undo log</code>有点类似。一般来说开启<code>bin log</code>都会给日志文件设置过期时间（<code>expire_logs_days</code>参数，默认永久保存），要不然日志的体量会非常庞大。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;expire_logs_days&#39;;
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| expire_logs_days | 0     |
+------------------+-------+
1 row in set

mysql&gt; SET GLOBAL expire_logs_days=30;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>主要应用于MySQL主从模式（<code>master-slave</code>）中，主从节点间的数据同步；以及基于时间点的数据还原。</p><p><strong>主从同步</strong></p><p>通过下图MySQL的主从复制过程，来了解下<code>bin log</code>在主从模式下的应用。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/pBBGas.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>用户在主库<code>master</code>执行<code>DDL</code>和<code>DML</code>操作，修改记录顺序写入<code>bin log</code>;</li><li>从库<code>slave</code>的I/O线程连接上Master，并请求读取指定位置<code>position</code>的日志内容;</li><li><code>Master</code>收到从库<code>slave</code>请求后，将指定位置<code>position</code>之后的日志内容，和主库bin log文件的名称以及在日志中的位置推送给从库;</li><li>slave的I/O线程接收到数据后，将接收到的日志内容依次写入到<code>relay log</code>文件最末端，并将读取到的主库bin log文件名和位置<code>position</code>记录到<code>master-info</code>文件中，以便在下一次读取用;</li><li>slave的SQL线程检测到<code>relay log</code>中内容更新后，读取日志并解析成可执行的SQL语句，这样就实现了主从库的数据一致;</li></ul><p><strong>基于时间点还原</strong></p><p>我们看到<code>bin log</code>也可以做数据的恢复，而<code>redo log</code>也可以，那它们有什么区别？</p><ul><li>层次不同：redo log 是InnoDB存储引擎实现的，bin log 是MySQL的服务器层实现的，但MySQL数据库中的任何存储引擎对于数据库的更改都会产生bin log。</li><li>作用不同：redo log 用于碰撞恢复（<code>crash recovery</code>），保证MySQL宕机也不会影响持久性；bin log 用于时间点恢复（<code>point-in-time recovery</code>），保证服务器可以基于时间点恢复数据和主从复制。</li><li>内容不同：redo log 是物理日志，内容基于磁盘的页<code>Page</code>；bin log的内容是二进制，可以根据<code>binlog_format</code>参数自行设置。</li><li>写入方式不同：redo log 采用循环写的方式记录；binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上。</li><li>刷盘时机不同：bin log在事务提交时写入；redo log 在事务开始时即开始写入。</li></ul><p>bin log 与 redo log 功能并不冲突而是起到相辅相成的作用，需要二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><p><strong>relay log（中继日志）</strong></p><p><code>relay log</code>日志文件具有与<code>bin log</code>日志文件相同的格式，从上边MySQL主从复制的流程可以看出，<code>relay log</code>起到一个中转的作用，<code>slave</code>先从主库<code>master</code>读取二进制日志数据，写入从库本地，后续再异步由<code>SQL线程</code>读取解析<code>relay log</code>为对应的SQL命令执行。</p><p><strong>slow query log</strong></p><p>慢查询日志（<code>slow query log</code>）: 用来记录在 MySQL 中执行时间超过指定时间的查询语句，在 SQL 优化过程中会经常使用到。通过慢查询日志，我们可以查找出哪些查询语句的执行效率低，耗时严重。</p><p>出于性能方面的考虑，一般只有在排查慢SQL、调试参数时才会开启，默认情况下，慢查询日志功能是关闭的。可以通过以下命令查看是否开启慢查询日志：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;slow_query%&#39;;
+---------------------+--------------------------------------------------------+
| Variable_name       | Value                                                  |
+---------------------+--------------------------------------------------------+
| slow_query_log      | OFF                                                    |
| slow_query_log_file | /usr/local/mysql/data/iZ2zebfzaequ90bdlz820sZ-slow.log |
+---------------------+--------------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过如下命令开启慢查询日志后，我发现 <code>iZ2zebfzaequ90bdlz820sZ-slow.log</code> 日志文件里并没有内容啊，可能因为我执行的 SQL 都比较简单没有超过指定时间。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt;  SET GLOBAL slow_query_log=ON;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上边提到超过 <code>指定时间</code> 的查询语句才算是慢查询，那么这个时间阈值又是多少嘞？我们通过 <code>long_query_time</code> 参数来查看一下，发现默认是 10 秒。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;long_query_time&#39;;
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们将 <code>long_query_time</code> 参数改小为 0.001秒再次执行查询SQL，看看慢查询日志里是否有变化。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SET GLOBAL long_query_time=0.001;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>果然再执行 SQL 的时，执行时间大于 0.001秒，发现慢查询日志开始记录了。</p><p><strong>general query log</strong></p><p>一般查询日志（<code>general query log</code>）：用来记录用户的<strong>所有</strong>操作，包括客户端何时连接了服务器、客户端发送的所有<code>SQL</code>以及其他事件，比如 <code>MySQL</code> 服务启动和关闭等等。<code>MySQL</code>服务器会按照它接收到语句的先后顺序写入日志文件。</p><p>由于一般查询日志记录的内容过于详细，开启后 Log 文件的体量会非常庞大，所以出于对性能的考虑，默认情况下，该日志功能是关闭的，通常会在排查故障需获得详细日志的时候才会临时开启。</p><p>我们可以通过以下命令查看一般查询日志是否开启，命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;general_log&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| general_log   | OFF   |
+---------------+-------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下边开启一般查询日志并查看日志存放的位置。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SET GLOBAL general_log=on;
Query OK, 0 rows affected
mysql&gt; show variables like &#39;general_log_file&#39;;
+------------------+---------------------------------------------------+
| Variable_name    | Value                                             |
+------------------+---------------------------------------------------+
| general_log_file | /usr/local/mysql/data/iZ2zebfzaequ90bdlz820sZ.log |
+------------------+---------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行一条查询 SQL 看看日志内容的变化。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from t_config;
+---------------------+------------+---------------------+---------------------+
| id                  | remark     | create_time         | last_modify_time    |
+---------------------+------------+---------------------+---------------------+
| 1325741604307734530 | 我是广播表 | 2020-11-09 18:06:44 | 2020-11-09 18:06:44 |
+---------------------+------------+---------------------+---------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到日志内容详细的记录了所有执行的命令、SQL、SQL的解析过程、数据库设置等等</p><p><strong>error log</strong></p><p>错误日志（<code>error log</code>）: 应该是 MySQL 中最好理解的一种日志，主要记录 MySQL 服务器每次启动和停止的时间以及诊断和出错信息。</p><p>默认情况下，该日志功能是开启的，通过如下命令查找错误日志文件的存放路径。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;log_error&#39;;
+---------------+----------------------------------------------------------------+
| Variable_name | Value                                                          |
+---------------+----------------------------------------------------------------+
| log_error     | /usr/local/mysql/data/LAPTOP-UHQ6V8KP.err |
+---------------+----------------------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：错误日志中记录的可并非全是错误信息，像 MySQL 如何启动 <code>InnoDB</code> 的表空间文件、如何初始化自己的存储引擎，初始化 <code>buffer pool</code> 等等，这些也记录在错误日志文件中。</p><h3 id="mysql中的锁" tabindex="-1"><a class="header-anchor" href="#mysql中的锁" aria-hidden="true">#</a> mysql中的锁</h3><p><strong>行级锁和表级锁及页级锁</strong></p><blockquote><p><strong>在MySQL数据库体系中，可以按照锁的粒度把数据库锁分为行级锁(Innodb引擎)、表级锁(MyISam引擎)和页级锁(BDB引擎 )</strong>。</p></blockquote><p><strong>行级锁</strong></p><ul><li><strong>行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。</strong><ul><li><strong>行级锁能大大减少数据库操作的冲突</strong>。</li><li><strong>其加锁粒度最小，但加锁的开销也最大</strong>。</li></ul></li></ul><blockquote><p><strong>行级锁分为共享锁和排他锁。具体针对于这两种锁会在后续介绍</strong>。</p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销大，加锁慢</strong>；</li><li><strong>会出现死锁</strong>；</li><li><strong>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</strong></li></ul></li></ul><p><strong>表级锁</strong></p><blockquote><p><strong>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持</strong>。</p></blockquote><ul><li>最常使用的MYISAM与INNODB都支持表级锁定。</li></ul><blockquote><p><strong>表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</strong>。</p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销小，加锁快</strong>；</li><li><strong>不会出现死锁</strong>；</li><li><strong>锁定粒度大，发出锁冲突的概率最高，并发度最低</strong>。</li></ul></li></ul><p><strong>页级锁</strong></p><blockquote><p><strong>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。</strong></p></blockquote><blockquote><p><strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。</strong></p></blockquote><blockquote><p><strong>所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</strong></p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销和加锁时间界于表锁和行锁之间；</strong></li><li><strong>会出现死锁；</strong></li><li><strong>锁定粒度界于表锁和行锁之间，并发度一般</strong></li></ul></li></ul><p><strong>MySQL常用存储引擎的锁机制</strong></p><ul><li><strong>MyISAM和MEMORY采用表级锁(table-level locking)</strong></li><li><strong>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</strong></li><li><strong>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</strong></li></ul><p><strong>Innodb中的行锁与表锁</strong></p><ul><li><strong>Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</strong><ul><li><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</strong></li><li><strong>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></li></ul></li></ul><blockquote><p><strong>实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</strong></p></blockquote><ul><li>在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。 <ul><li><strong>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</strong>。</li><li><strong>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁</strong>。</li></ul></li></ul><blockquote><p><strong>即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁,而不是行锁</strong>。</p></blockquote><blockquote><p><strong>因此，在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。</strong></p></blockquote><p><strong>行级锁与死锁</strong></p><blockquote><p><strong>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待</strong>。</p></blockquote><ul><li><strong>在InnoDB中，锁是逐步获得的，就造成了死锁的可能。行级锁并不是直接锁记录，而是锁索引</strong>。 <ul><li><strong>索引分为主键索引和非主键索引两种：</strong><ul><li><strong>如果一条语句操作了主键索引，MySQL就会锁定这条主键索引</strong>；</li><li><strong>如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引</strong>。</li></ul></li></ul></li></ul><blockquote><p><strong>在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking</strong>。</p></blockquote><ul><li>当两个事务同时执行： <ul><li><strong>一个锁住了主键索引，在等待其他相关索引</strong>。</li><li><strong>另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁</strong>。</li></ul></li></ul><blockquote><p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p></blockquote><ul><li>有多种方法可以避免死锁，这里只介绍常见的三种 <ol><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li></ol></li></ul><p><strong>共享锁与排他锁</strong></p><blockquote><p><strong>上面介绍过，行级锁是MySQL中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。</strong></p></blockquote><p>行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。</p><p><strong>共享锁(Share Lock)</strong></p><blockquote><p><strong>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁</strong>。</p></blockquote><blockquote><p><strong>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据</strong>。</p></blockquote><p>用法</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>在查询语句后面增加<strong>LOCK IN SHARE MODE</strong>，<strong>MySQL会对查询结果中的每行都加共享锁</strong>。</li><li><strong>当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞</strong>。<strong>其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据</strong>。</li></ul><p><strong>排他锁（exclusive Lock）</strong></p><ul><li><strong>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据</strong>。</li></ul><blockquote><p><strong>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）</strong></p></blockquote><p>用法</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p><strong>在查询语句后面增加FOR UPDATE，MySQL会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</strong></p></blockquote><p><strong>意向锁</strong></p><blockquote><p><strong>意向锁是一种不与行级锁冲突表级锁，这一点非常重要。意向锁分为两种： 1. 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） 2. 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） 即：意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InnoDB会先获取该数据行所在在数据表的对应意向锁</strong>。</p></blockquote><p>InnoDB支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</p><ul><li><strong>意向锁之间互不排斥，但除了IS与S兼容外，意向锁会与共享锁 / 排他锁 互斥。</strong></li><li><strong>IX，IS是表级锁，不会和行级的X，S锁发生冲突</strong>。只会和表级的X，S发生冲突。</li><li><strong>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</strong></li></ul><hr><ul><li><strong>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</strong>。</li><li><strong>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁</strong>。</li></ul><blockquote><p><strong>对于一般的Select语句，InnoDB不会加任何锁(快照读)。</strong></p></blockquote><h3 id="mysql日期类型选择" tabindex="-1"><a class="header-anchor" href="#mysql日期类型选择" aria-hidden="true">#</a> mysql日期类型选择</h3><p>在 MySQL 数据库中，选择合适的日期类型对于正确存储和操作日期数据非常重要。以下是一些建议：</p><ol><li><strong>DATE</strong>：如果只需要存储日期信息（年、月、日），而不需要精确到具体的时分秒，可以使用 DATE 类型。DATE 类型占用 3 字节的存储空间，范围从 &#39;1000-01-01&#39; 到 &#39;9999-12-31&#39;。</li><li><strong>DATETIME</strong>：如果需要同时存储日期和时间信息，并且需要精确到秒级别，可以使用 DATETIME 类型。DATETIME 类型占用 8 字节的存储空间，范围从 &#39;1000-01-01 00:00:00&#39; 到 &#39;9999-12-31 23:59:59&#39;。</li><li><strong>TIMESTAMP</strong>：TIMESTAMP 类型也用于存储日期和时间信息，精确度为秒级，但它在存储和显示时会受到<strong>时区</strong>的影响。TIMESTAMP 类型占用 4 字节的存储空间，范围从 &#39;1970-01-01 00:00:01&#39; UTC 到 &#39;2038-01-19 03:14:07&#39; UTC。</li><li><strong>TIME</strong>：如果只需要存储时间信息（时、分、秒），可以使用 TIME 类型。TIME 类型占用 3 字节的存储空间，范围从 &#39;-838:59:59&#39; 到 &#39;838:59:59&#39;。</li><li><strong>YEAR</strong>：如果只需要存储年份信息，可以使用 YEAR 类型。YEAR 类型占用 1 字节的存储空间，范围从 1901 到 2155。</li></ol><p>根据实际需求选择合适的日期类型，可以有效地节省存储空间并确保数据存储的准确性和完整性。同时，还需考虑到对日期数据的查询和操作需求，以便选择最适合的日期类型。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/springboot4/edit/main/src/article/offer/03-mysql.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 2235602974@qq.com">付绪壮</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-f9138082.js" defer></script>
  </body>
</html>
